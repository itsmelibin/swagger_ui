{
  "swagger": "2.0",
  "info": {
    "description": "The HERE Fleet Telematics API is a set of REST resources for advanced fleet telematics on top of the HERE Location Services. It supersedes the services CLE, CRE, GFE, GFE-onMaps, PDE, RME, TCE and WSE.",
    "version": "3.0.31",
    "title": "Fleet Telematics API Documentation",
    "contact": [

    ],
    "license": [

    ],
    "x-document-meta-data": {
      "copyright": "Â© 2020 HERE Europe B.V.",
      "document-id": "000aeced-9942-469c-a56a-0f0d907624b4",
      "date-created": "2020-05-29T08:53:07+00:00"
    }
  },
  "host": "fleet.ls.hereapi.com",
  "basePath": "/",
  "tags": [
    {
      "name": "Routing & Route Matching",
      "description": "Route calculation with enterprise features"
    },
    {
      "name": "Upload Data",
      "description": "Upload custom roads/restrictions and custom POIs"
    },
    {
      "name": "Search",
      "description": "Retrieve map features & custom features"
    }
  ],
  "paths": {
    "/1/doc/attributes.json": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "List the layer attributes across all layers",
        "description": "List the map layer attributes across all layers. Does not list the custom layers.",
        "operationId": "attributesJSONUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8"
        ],
        "parameters": [
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "description": "app_code",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/AttributeDocBean"
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/1/doc/indexes.json": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "List available layer indexes",
        "description": "List the available indexes of all available layers. Does not list indexes of custom layers.",
        "operationId": "indexesJSONUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8"
        ],
        "parameters": [
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "description": "app_code",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IndexDocBean"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/1/doc/layer.json": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "List the layer attributes",
        "description": "List the attributes of a given layer. Does not list the custom layers.",
        "operationId": "layerJSONUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8"
        ],
        "parameters": [
          {
            "name": "layer",
            "in": "query",
            "description": "layer",
            "required": false,
            "type": "string"
          },
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "description": "app_code",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LayerDetailDocBean"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/1/doc/layers.json": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "List the available map layers",
        "description": "List available map layers. To see only the layers of a given map region, like Postal Code Boundaries, then specify it as map 'region'. Does not list the custom layers.",
        "operationId": "layersJSONUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8"
        ],
        "parameters": [
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "description": "app_code",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/LayerDocBean"
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/1/doc/maps.json": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "List available map regions/releases",
        "description": "List available map regions/releases. Does not list custom maps.",
        "operationId": "mapsJSONUsingGET_1",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8"
        ],
        "parameters": [
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "description": "app_code",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/MapDocResponse"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/1/doc/scontent.json": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "List static layer's attributes",
        "description": "List the attributes of a given static (non tiled) layer. Does not work for custom layers.",
        "operationId": "staticContentJSONUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "description": "Static content layer name",
            "required": false,
            "type": "string"
          },
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "description": "app_code",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/StaticContentDetailDocBean"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/1/doc/scontents.json": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "List static content layers",
        "description": "List the available static content (non-tiled) layers. Does not list custom layers.",
        "operationId": "staticContentsJSONUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8"
        ],
        "parameters": [
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "description": "app_code",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/StaticContentDocBean"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/1/file.bin": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "File content",
        "description": "Retrieve the binary content of a file, like a junction view image",
        "operationId": "getFileUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/octet-stream"
        ],
        "parameters": [
          {
            "name": "layer",
            "in": "query",
            "description": "layer name",
            "required": false,
            "type": "string"
          },
          {
            "name": "path",
            "in": "query",
            "description": "file path, as specified in the referencing layer's attribute value",
            "required": false,
            "type": "string"
          },
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/1/index.json": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "Tile IDs containing a given value",
        "description": "Retrieve the IDs of tiles that contain a given (set of) attribute value(s). Does not work for custom layers.",
        "operationId": "indexJSONUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8"
        ],
        "parameters": [
          {
            "name": "layer",
            "in": "query",
            "description": "layer name",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "attributes",
            "in": "query",
            "description": "comma separated list of index attribute names",
            "required": false,
            "type": "string"
          },
          {
            "name": "values",
            "in": "query",
            "description": "comma separated list of index attribute values, corresponding to the attribute names",
            "required": false,
            "type": "string"
          },
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/IndexResponse"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/1/search/bbox.json": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "Retrieve layer content within given geo rectangle",
        "description": "Retrieve the layer content records within given geo bounding box. Does not work for custom layers.",
        "operationId": "searchBboxUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8"
        ],
        "parameters": [
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "description": "app_code",
            "required": false,
            "type": "string"
          },
          {
            "name": "layer_id",
            "in": "query",
            "description": "Layer name to be searched. Layer name is not case sensitive. The maximum length of a layer name and the permitted characters can be looked up up in the service via /serviceconfiguration.json",
            "required": false,
            "type": "string"
          },
          {
            "name": "key_attribute",
            "in": "query",
            "description": "the key column(s) of this layer, as defined in the layer specification",
            "required": false,
            "type": "string"
          },
          {
            "name": "attributes",
            "in": "query",
            "description": "List of comma separated column names to specify which attributes shall appear in the result. Column names are not case sensitive. Default = all.",
            "required": false,
            "type": "string"
          },
          {
            "name": "bbox",
            "in": "query",
            "description": "The bounding box upper, left, lower and right coordinates in WGS84 degrees. All geometries overlapping this rectangle will be returned.\r\nThe format is latitude,longitude;latitude,longitude.\r\nExample: bbox=37.8,-122.1;37.2,-122.0",
            "required": false,
            "type": "string"
          },
          {
            "name": "geom",
            "in": "query",
            "description": "local, full or none. Specifies the geometry representation in the result. Default = local. Local geometry is used for map display purposes, returning geometry pieces that cover the given search radius, bounding box or corridor polygon. Full geometry is used for interactive editing, where the original geometry is required. None is used for applications like geofencing, which most of the time want to know only the ids of the geofence points/lines polygons they are in or near.",
            "required": false,
            "type": "string",
            "default": "local"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "region",
            "in": "query",
            "description": "Optional (default=whole world excl. JPN, CHN, SK). Map coverage region, e.g. APAC, AUS, WEU, IND, MEA, NA, SAM, TWN, JPN. The region may contain hints to distinguish specific content. E.g. there can be an WEU and PCBEU, where the 2nd map contains only Postal Code Boundary layers. If not specified, the service will find the region(s) automatically, that cover the request. The parameter can contain a comma separated list of regions (f.e. WEU,MEA). If the region parameter is specified, the service will use these region(s) and skip region(s) that may also cover the response (f.e. EEU). Except of JPN, specifying a region is strongly discouraged, because regions might change and hence applications that specify a region might stop working when the region gets discontinued, renamed, split or changed otherwise. As the APAC region contains a simplified entry map content of JPN, JPN needs to be specified as region to access the full JPN content.",
            "required": false,
            "type": "string"
          },
          {
            "name": "release",
            "in": "query",
            "description": "Map release quarter, e.g. 2015Q4, 161J0, 16153 or LATEST (= default) for the latest available map release quarter. Specifying a map release is strongly discouraged, because there is no guarantee how long old map releases are available, hence applications that specify a release might stop working when the release gets retired. To choose a specific snapshot of the weather archive layer, a UNIX timestamp (number of milliseconds since 1970) or a date in 2017-12-01T17:30:00+01:00 format can be passed.",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/GeometrySearchResponse"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/1/search/corridor.json": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "Retrieve layer content within given geo corridor",
        "description": "Retrieve the layer content records within an airline distance along a given polyline. Does not work for custom layers.",
        "operationId": "searchCorridorUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8"
        ],
        "parameters": [
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "description": "app_code",
            "required": false,
            "type": "string"
          },
          {
            "name": "layer_ids",
            "in": "query",
            "description": "Comma separated list of layer names to be searched. Layer names are not case sensitive. The maximum length of a layer name and the permitted characters can be looked up up in the service via /serviceconfiguration.json",
            "required": false,
            "type": "string"
          },
          {
            "name": "key_attributes",
            "in": "query",
            "description": "the key column(s) of this layer, as defined in the layer specification",
            "required": true,
            "type": "string"
          },
          {
            "name": "attributes",
            "in": "query",
            "description": "List of comma separated column names to specify which attributes shall appear in the result. Column names are not case sensitive. Default = all.",
            "required": false,
            "type": "string"
          },
          {
            "name": "corridor",
            "in": "query",
            "description": "Either corridor or route_id is required.\r\nThe WGS84 degree coordinates of the polyline used as corridor center line.\r\nFor example:\r\nlatitude 1,longitude 1;latitude 2,longitude 2;...",
            "required": false,
            "type": "string"
          },
          {
            "name": "route_id",
            "in": "query",
            "description": "Either corridor or route_id is required.\r\nA route_id obtained from a previous Router call. This route_id will be turned into a corridor polyline.",
            "required": false,
            "type": "string"
          },
          {
            "name": "radius",
            "in": "query",
            "description": "The buffer search radius in meters.All geometries overlapping the corridor polygon will be returned.",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "geom",
            "in": "query",
            "description": "local, full or none. Specifies the geometry representation in the result. Default = local. Local geometry is used for map display purposes, returning geometry pieces that cover the given search radius, bounding box or corridor polygon. Full geometry is used for interactive editing, where the original geometry is required. None is used for applications like geofencing, which most of the time want to know only the ids of the geofence points/lines polygons they are in or near.",
            "required": false,
            "type": "string",
            "default": "local"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "mode",
            "in": "query",
            "description": "fastest;car;traffic:disabled;... or fastest;car;traffic:disabled;It determines how the route is calculated. When route_id is used for the corridor search then please specify the same mode which was used to get the route id.",
            "required": false,
            "type": "string"
          },
          {
            "name": "region",
            "in": "query",
            "description": "Optional (default=whole world excl. JPN, CHN, SK). Map coverage region, e.g. APAC, AUS, WEU, IND, MEA, NA, SAM, TWN, JPN. The region may contain hints to distinguish specific content. E.g. there can be an WEU and PCBEU, where the 2nd map contains only Postal Code Boundary layers. If not specified, the service will find the region(s) automatically, that cover the request. The parameter can contain a comma separated list of regions (f.e. WEU,MEA). If the region parameter is specified, the service will use these region(s) and skip region(s) that may also cover the response (f.e. EEU). Except of JPN, specifying a region is strongly discouraged, because regions might change and hence applications that specify a region might stop working when the region gets discontinued, renamed, split or changed otherwise. As the APAC region contains a simplified entry map content of JPN, JPN needs to be specified as region to access the full JPN content.",
            "required": false,
            "type": "string"
          },
          {
            "name": "release",
            "in": "query",
            "description": "Map release quarter, e.g. 2015Q4, 161J0, 16153 or LATEST (= default) for the latest available map release quarter. Specifying a map release is strongly discouraged, because there is no guarantee how long old map releases are available, hence applications that specify a release might stop working when the release gets retired. To choose a specific snapshot of the weather archive layer, a UNIX timestamp (number of milliseconds since 1970) or a date in 2017-12-01T17:30:00+01:00 format can be passed.",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/GeometrySearchResponse"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/1/search/quadkey.json": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "Retrieve layer content within a quadkey",
        "description": "Retrieve the layer content records within a given geo rectangle specified by a (standard WGS84 Mercator) quadkey. Does not work for custom layers.",
        "operationId": "searchQuadKeyUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8"
        ],
        "parameters": [
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "description": "app_code",
            "required": false,
            "type": "string"
          },
          {
            "name": "layer_id",
            "in": "query",
            "description": "Layer name to be searched. Layer name is not case sensitive. The maximum length of a layer name and the permitted characters can be looked up up in the service via /serviceconfiguration.json",
            "required": false,
            "type": "string"
          },
          {
            "name": "key_attribute",
            "in": "query",
            "description": "the key column(s) of this layer, as defined in the layer specification",
            "required": false,
            "type": "string"
          },
          {
            "name": "attributes",
            "in": "query",
            "description": "List of comma separated column names to specify which attributes shall appear in the result. Column names are not case sensitive. Default = all.",
            "required": false,
            "type": "string"
          },
          {
            "name": "quad_key",
            "in": "query",
            "description": "The quad key number of the map tile area to search from.",
            "required": false,
            "type": "string"
          },
          {
            "name": "geom",
            "in": "query",
            "description": "local, full or none. Specifies the geometry representation in the result. Default = local. Local geometry is used for map display purposes, returning geometry pieces that cover the given search radius, bounding box or corridor polygon. Full geometry is used for interactive editing, where the original geometry is required. None is used for applications like geofencing, which most of the time want to know only the ids of the geofence points/lines polygons they are in or near.",
            "required": false,
            "type": "string",
            "default": "local"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "region",
            "in": "query",
            "description": "Optional (default=whole world excl. JPN, CHN, SK). Map coverage region, e.g. APAC, AUS, WEU, IND, MEA, NA, SAM, TWN, JPN. The region may contain hints to distinguish specific content. E.g. there can be an WEU and PCBEU, where the 2nd map contains only Postal Code Boundary layers. If not specified, the service will find the region(s) automatically, that cover the request. The parameter can contain a comma separated list of regions (f.e. WEU,MEA). If the region parameter is specified, the service will use these region(s) and skip region(s) that may also cover the response (f.e. EEU). Except of JPN, specifying a region is strongly discouraged, because regions might change and hence applications that specify a region might stop working when the region gets discontinued, renamed, split or changed otherwise. As the APAC region contains a simplified entry map content of JPN, JPN needs to be specified as region to access the full JPN content.",
            "required": false,
            "type": "string"
          },
          {
            "name": "release",
            "in": "query",
            "description": "Map release quarter, e.g. 2015Q4, 161J0, 16153 or LATEST (= default) for the latest available map release quarter. Specifying a map release is strongly discouraged, because there is no guarantee how long old map releases are available, hence applications that specify a release might stop working when the release gets retired. To choose a specific snapshot of the weather archive layer, a UNIX timestamp (number of milliseconds since 1970) or a date in 2017-12-01T17:30:00+01:00 format can be passed.",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/GeometrySearchResponse"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/1/serviceconfiguration.json": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "Service parameter boundary values",
        "description": "Numeric constants and limits for the service calls. Will never become more strict, but can become more relaxed in future releases.",
        "operationId": "getServiceConfigurationUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ServiceConfigurationResponse"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/1/static.json": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "Static layer's content",
        "description": "Retrieve the rows from the static layer's content. Does not include custom layers.",
        "operationId": "staticJSONUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8"
        ],
        "parameters": [
          {
            "name": "content",
            "in": "query",
            "description": "Static content layer name",
            "required": false,
            "type": "string"
          },
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "description": "app_code",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "link2stabletopologyid",
            "in": "query",
            "description": "Optional. If '1' then the result records have 2 additional columns: TOPOLOGY_ID and START_OFFSET. The HERE topology segment PVID identifies a stretch of roads between 2 intersections. Links are subsets of a topology segment, hence the offset attributes define the range of the link within the topology segment [0..1].",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TileResponse"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/1/tile.json": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "Tile of rows from a layer",
        "description": "Retrieve the rows from within a given tile of this layer. Does not work for custom layers.",
        "operationId": "tileJsonUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8"
        ],
        "parameters": [
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "description": "app_code",
            "required": false,
            "type": "string"
          },
          {
            "name": "layer",
            "in": "query",
            "description": "Thematic layer name",
            "required": false,
            "type": "string"
          },
          {
            "name": "region",
            "in": "query",
            "description": "Optional (default=whole world excl. JPN, CHN, SK). Map coverage region, e.g. APAC, AUS, WEU, IND, MEA, NA, SAM, TWN, JPN. The region may contain hints to distinguish specific content. E.g. there can be an WEU and PCBEU, where the 2nd map contains only Postal Code Boundary layers. If not specified, the service will find the region(s) automatically, that cover the request. The parameter can contain a comma separated list of regions (f.e. WEU,MEA). If the region parameter is specified, the service will use these region(s) and skip region(s) that may also cover the response (f.e. EEU). Except of JPN, specifying a region is strongly discouraged, because regions might change and hence applications that specify a region might stop working when the region gets discontinued, renamed, split or changed otherwise. As the APAC region contains a simplified entry map content of JPN, JPN needs to be specified as region to access the full JPN content.",
            "required": false,
            "type": "string"
          },
          {
            "name": "release",
            "in": "query",
            "description": "Map release quarter, e.g. 2015Q4, 161J0, 16153 or LATEST (= default) for the latest available map release quarter. Specifying a map release is strongly discouraged, because there is no guarantee how long old map releases are available, hence applications that specify a release might stop working when the release gets retired. To choose a (nearest to) specific snapshot of the live traffic speed record layer, a UNIX timestamp (number of milliseconds since 1970) or a date in 2017-12-01T17:30:00+01:00 format can be passed.",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "level",
            "in": "query",
            "description": "Level of the requested layer, as specified in layer's documentation.",
            "required": false,
            "type": "string"
          },
          {
            "name": "tilex",
            "in": "query",
            "description": "Tile number in West-East direction. Depends on the level. The tile covering the longitude LON [WGS84 degree] has tileX = floor((LON + 180.0) / tileSize), where tileSize = 180 / 2^level. The tile with a given tileX value covers the longitude range [ tileX * tileSize - 180.0 ... (tileX + 1) * tileSize - 180.0 ].",
            "required": false,
            "type": "string"
          },
          {
            "name": "tiley",
            "in": "query",
            "description": "Tile number in South-North direction. Depends on the level. The tile covering the latitude LAT [WGS84 degree] has tileY = floor((LAT + 90.0) / tileSize), where tileSize = 180 / (2^level). The tile with a given tileY value covers the latitude range [ tileY * tileSize - 90.0 ... (tileY + 1) * tileSize - 90.0 [.",
            "required": false,
            "type": "string"
          },
          {
            "name": "meta",
            "in": "query",
            "description": "Optional. If '1' then each response tile is framed with meta information (layer, level, tilex, tiley, region, release).",
            "required": false,
            "type": "string"
          },
          {
            "name": "cols",
            "in": "query",
            "description": "Optional. Selects the subset of attributes in the response. Semicolon separated list of attributes, within a per-tile comma separated list. Example: cols=LAT;LON,LAT will retain only LAT and LON in first tile's result rows and retain only LAT in second tile's result.",
            "required": false,
            "type": "string"
          },
          {
            "name": "link2stabletopologyid",
            "in": "query",
            "description": "Optional. If '1' then the result records have 2 additional columns: TOPOLOGY_ID and START_OFFSET. The HERE topology segment PVID identifies a stretch of roads between 2 intersections. Links are subsets of a topology segment, hence the offset attributes define the range of the link within the topology segment [0..1].",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TileResponse"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/1/tiles.json": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "Multiple tiles' rows from layer(s)",
        "description": "Retrieve the rows from within given tile(s) out of one or more layers. Does not work for custom layers.",
        "operationId": "tilesJSONUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8"
        ],
        "parameters": [
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "description": "app_code",
            "required": false,
            "type": "string"
          },
          {
            "name": "layers",
            "in": "query",
            "description": "Thematic Layer names, one per requested tile, comma separated list.",
            "required": false,
            "type": "string"
          },
          {
            "name": "region",
            "in": "query",
            "description": "Optional (default=whole world excl. JPN, CHN, SK). Map coverage region, e.g. APAC, AUS, WEU, IND, MEA, NA, SAM, TWN, JPN. The region may contain hints to distinguish specific content. E.g. there can be an WEU and PCBEU, where the 2nd map contains only Postal Code Boundary layers. If not specified, the service will find the region(s) automatically, that cover the request. The parameter can contain a comma separated list of regions (f.e. WEU,MEA). If the region parameter is specified, the service will use these region(s) and skip region(s) that may also cover the response (f.e. EEU). Except of JPN, specifying a region is strongly discouraged, because regions might change and hence applications that specify a region might stop working when the region gets discontinued, renamed, split or changed otherwise. As the APAC region contains a simplified entry map content of JPN, JPN needs to be specified as region to access the full JPN content.",
            "required": false,
            "type": "string"
          },
          {
            "name": "release",
            "in": "query",
            "description": "Map release quarter, e.g. 2015Q4, 161J0, 16153 or LATEST (= default) for the latest available map release quarter. Specifying a map release is strongly discouraged, because there is no guarantee how long old map releases are available, hence applications that specify a release might stop working when the release gets retired. To choose a (nearest to) specific snapshot of the live traffic speed record layer, a UNIX timestamp (number of milliseconds since 1970) or a date in 2017-12-01T17:30:00+01:00 format can be passed.",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "levels",
            "in": "query",
            "description": "Level of each requested layer, as specified in the layers' documentation, comma separated list.",
            "required": false,
            "type": "string"
          },
          {
            "name": "tilexy",
            "in": "query",
            "description": "Comma separated sequence of tilex,tiley pairs for the requested tiles. The tilex and tiley values are described in the tile.json resource.",
            "required": false,
            "type": "string"
          },
          {
            "name": "meta",
            "in": "query",
            "description": "Optional. If '1' then each response tile is framed with meta information (layer, level, tilex, tiley, region, release).",
            "required": false,
            "type": "string"
          },
          {
            "name": "cols",
            "in": "query",
            "description": "Optional. Selects the subset of attributes in the response. Semicolon separated list of attributes, within a per-tile comma separated list. Example: cols=LAT;LON,LAT will retain only LAT and LON in first tile's result rows and retain only LAT in second tile's result.",
            "required": false,
            "type": "string"
          },
          {
            "name": "link2stabletopologyid",
            "in": "query",
            "description": "Optional. If '1' then the result records have 2 additional columns: TOPOLOGY_ID and START_OFFSET. The HERE topology segment PVID identifies a stretch of roads between 2 intersections. Links are subsets of a topology segment, hence the offset attributes define the range of the link within the topology segment [0..1].",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/TileResponse"
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/2/calculateroute.json": {
      "get": {
        "tags": [
          "Routing & Route Matching"
        ],
        "summary": "Calculates a route with additional fleet telematics features",
        "description": "Calculates a route with additional fleet telematics features.\r\nThis resource provides a similar interface as the Routing REST API.\r\nNote: If using the cre.api.here.com endpoint, then requests that don't need specific features may get redirected to the Routing REST API. This doesn't happen when usgin the fleet.api.here.com endpoint.",
        "operationId": "calculateRouteUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8",
          "multipart/form-data"
        ],
        "parameters": [
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": false,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "description": "app_code",
            "required": false,
            "type": "string"
          },
          {
            "name": "driver_cost",
            "in": "query",
            "description": "Cost per hour in target currency.",
            "required": false,
            "type": "string"
          },
          {
            "name": "vehicle_cost",
            "in": "query",
            "description": "Cost per kilometer in target currency.",
            "required": false,
            "type": "string"
          },
          {
            "name": "vehicleCostOnFerry",
            "in": "query",
            "description": "Cost per kilometer on ferry in target currency.",
            "required": false,
            "type": "string"
          },
          {
            "name": "currency",
            "in": "query",
            "description": "3 letter ISO currency symbol, like EUR or USD. Required if toll cost must be added up across different currencies and/or be added to driver/vehicle/fuel cost in different currencies.",
            "required": false,
            "type": "string"
          },
          {
            "name": "region",
            "in": "query",
            "description": "Optional (default=whole world excl. JPN, CHN, SK). Map coverage region, e.g. APAC, AUS, WEU, IND, MEA, NA, SAM, TWN, JPN. The region may contain hints to distinguish specific content. E.g. there can be an WEU and PCBEU, where the 2nd map contains only Postal Code Boundary layers. If not specified, the service will find the region(s) automatically, that cover the request. The parameter can contain a comma separated list of regions (f.e. WEU,MEA). If the region parameter is specified, the service will use these region(s) and skip region(s) that may also cover the response (f.e. EEU). Except of JPN, specifying a region is strongly discouraged, because regions might change and hence applications that specify a region might stop working when the region gets discontinued, renamed, split or changed otherwise. As the APAC region contains a simplified entry map content of JPN, JPN needs to be specified as region to access the full JPN content.",
            "required": false,
            "type": "string"
          },
          {
            "name": "departure",
            "in": "query",
            "description": "Format: now, yyyy-MM-dd'T'HH:mm:ss or yyyy-MM-dd'T'HH:mm:ssX. If no timezone is specified, then the local timezone at the route start link is used. Default: Ignore all time dependent access restrictions. Special values: ignoreTimeDepRestr (like default), obeyTimeDepRestr (all time dependent restrictions apply).",
            "required": false,
            "type": "string"
          },
          {
            "name": "tollVehicleType",
            "in": "query",
            "description": "1=Motorcycle, 2=Auto, 3=Truck, 4=Motor home, 5=Minibus, 6=Bus, 7=Motorcycle Sidecar(EU), 8=Tricycle(EU), 9=Delivery Truck(EU+India), 10=Snowmobile(US), 11=Pick-up(US+India), 12=Tractor(US+India), 13=Taxi, 14=HCM/EME (India)",
            "required": false,
            "type": "string"
          },
          {
            "name": "trailerType",
            "in": "query",
            "description": "0=None, 1=Caravan, 2=Trailer. For toll cost.",
            "required": false,
            "type": "string"
          },
          {
            "name": "trailersCount",
            "in": "query",
            "description": "Number of trailers, 0...4. For toll cost and truck restrictions. 0=no trailer, 1=one or more trailers, 2=two or more trailers, 3=three or more trailers. For truck restrictions: 4=one or more semi-trailers.",
            "required": false,
            "type": "string"
          },
          {
            "name": "vehicleNumberAxles",
            "in": "query",
            "description": "Number of axles excluding trailers. For toll cost and for country wide truck restrictions.",
            "required": false,
            "type": "string"
          },
          {
            "name": "trailerNumberAxles",
            "in": "query",
            "description": "Number of trailer axles. For toll cost and for country wide truck restrictions.",
            "required": false,
            "type": "string"
          },
          {
            "name": "hybrid",
            "in": "query",
            "description": "1=fuel+electric, 0=otherwise. For toll cost.",
            "required": false,
            "type": "string"
          },
          {
            "name": "emissionType",
            "in": "query",
            "description": "1=EURO I, 2=EURO II, 3=EURO III, 4=EURO IV, 5=EURO V, 6=EURO VI, 7=EURO EEV, 8=Electric Vehicles. For toll cost and environmental zone restrictions.",
            "required": false,
            "type": "string"
          },
          {
            "name": "height",
            "in": "query",
            "description": "350cm or 3.5m or 138in. For truck restrictions and toll cost.",
            "required": false,
            "type": "string"
          },
          {
            "name": "trailerHeight",
            "in": "query",
            "description": "350cm or 3.5m or 138in. For toll cost.",
            "required": false,
            "type": "string"
          },
          {
            "name": "vehicleWeight",
            "in": "query",
            "description": "Actual total weight of vehicle incl. payload, but not trailers' weight or payload. 7.5t or 7500kg or 16500lbs. See also limitedWeight. For toll cost.",
            "required": false,
            "type": "string"
          },
          {
            "name": "limitedWeight",
            "in": "query",
            "description": "Actual total weight of vehicle incl. payload and trailers/caravan incl. their payload. 7.5t or 7500kg or 16500lbs. For truck restrictions, speed profile, toll cost and environmental zone restrictions. See also vehicleWeight.",
            "required": false,
            "type": "string"
          },
          {
            "name": "disabledEquipped",
            "in": "query",
            "description": "1=vehicle equipped to carry disabled people, 0=otherwise. For toll cost.",
            "required": false,
            "type": "string"
          },
          {
            "name": "passengersCount",
            "in": "query",
            "description": "actual number of passengers. For toll cost. See also vehicle type carHOV.",
            "required": false,
            "type": "string"
          },
          {
            "name": "tiresCount",
            "in": "query",
            "description": "Number of tires. For toll cost.",
            "required": false,
            "type": "string"
          },
          {
            "name": "commercial",
            "in": "query",
            "description": "1=vehicle registered for commercial use, 0=otherwise. For toll cost and environmental zone regulations.",
            "required": false,
            "type": "string"
          },
          {
            "name": "shippedHazardousGoods",
            "in": "query",
            "description": "Comma separated list from explosive, gas, flammable, combustible, organic, poison, radioActive, corrosive, poisonousInhalation, harmfulToWater, other, allhazardousGoods, explosiveFlammable. For toll cost (only explosive and other) and for truck restrictions.",
            "required": false,
            "type": "string"
          },
          {
            "name": "heightAbove1stAxle",
            "in": "query",
            "description": "350cm or 3.5m or 138in. For toll cost.",
            "required": false,
            "type": "string"
          },
          {
            "name": "length",
            "in": "query",
            "description": "350cm or 3.5m or 138in. For truck restrictions and toll cost.",
            "required": false,
            "type": "string"
          },
          {
            "name": "trailerWeight",
            "in": "query",
            "description": "Actual total weight of trailers with their payload. 7.5t or 7500kg or 16500lbs. See also limitedWeight. For toll cost.",
            "required": false,
            "type": "string"
          },
          {
            "name": "weightPerAxle",
            "in": "query",
            "description": "Actual total weight per axle, incl. payload. 7.5t or 7500kg or 16500lbs. For toll cost and truck restrictions.",
            "required": false,
            "type": "string"
          },
          {
            "name": "width",
            "in": "query",
            "description": "350cm or 3.5m or 138in. For truck restrictions.",
            "required": false,
            "type": "string"
          },
          {
            "name": "tunnelCategory",
            "in": "query",
            "description": "Defines the tunnel categories the truck must NOT use. B, C, D or E. A tunnels have no restrictions. E tunnels have most restrictions. If C is defined, the route will use A and B tunnels but not C, D or E.",
            "required": false,
            "type": "string"
          },
          {
            "name": "fuelType",
            "in": "query",
            "description": "Defines the fuel powering the vehicle. Can be Diesel, Petrol, LPG, LNG, CNG, Ethanol, Propane, Hydrogen, Electric. (LPG=Liquefied Petroleum Gas,  LNG=Liquefied Natural Gas). Used f.e. for environmental zone restrictions, toll cost calculation, consumption based routing for Electric vehicles.",
            "required": false,
            "type": "string"
          },
          {
            "name": "weightPerAxleGroup",
            "in": "query",
            "description": "Semicolon separated list of vehicle weight [tons] per axle group. Each item is a tupel (name,value). Supported names are single,and tandem. Example: &weightPerAxleGroup=single:12;tandem:18",
            "required": false,
            "type": "string"
          },
          {
            "name": "overlays",
            "in": "query",
            "description": "Overlay map name. Case insensitive. Must start with OVERLAY and contain only characters.",
            "required": false,
            "type": "string"
          },
          {
            "name": "mode",
            "in": "query",
            "description": "fastest;car;traffic:disabled;[optional parameters] As optional parameters motorway (0, -1, -2, -3), tollroad (0, -1, -2, -3), boatFerry (0, -1, -2, -3), railFerry (0, -1, -2, -3), and tunnel (0, -1, -2, -3) can follow. \"shortest\" and \"balanced\" are not supported but can be individually tuned using &driver_cost and &vehicle_cost. Vehicle types: bdouble, bicycle, bus, car, carHOV, custom1, emergency, motorcycle, pedestrian, roadtrain, taxi, truck",
            "required": false,
            "type": "string"
          },
          {
            "name": "restTimes",
            "in": "query",
            "description": "Legal drive/rest intervals. Specify 'local' to obey the legal driver rest times of the respective country. If the driver is not fresh then add ,TimeAlreadyDrivenSinceLastShortBreak,TimeAlreadyDrivenSinceLastLongRest in seconds. Alternatively, proprietary values can be set for DriveTimeUntilShortBreak, ElapsedTimeUntilShortBreak, ShortBreakDuration, DriveTimeUntilLongRest, ElapsedTimeUntilLongBreak, LongRestDuration. E.g. EU requires after 4.5h a 45min break + after 9h an 11h rest.",
            "required": false,
            "type": "string"
          },
          {
            "name": "language",
            "in": "query",
            "description": "Language for the maneuver instructions in the response. Currently de-de, en-us and it-it are supported. If not specified, en-us is used.",
            "required": false,
            "type": "string"
          },
          {
            "name": "avoidLinks",
            "in": "query",
            "description": "Comma separated list of link ids to be avoided. Positive ids are not driven from reference node, negative ids are not driven towards reference node. Use '*' prefix to avoid both directions.",
            "required": false,
            "type": "string"
          },
          {
            "name": "avoidAreas",
            "in": "query",
            "description": "List of areas (rectangles or polygons) to be avoided. Areas are separated by '!'. Rectangles can be specified with two diagonal coordinates separated by ';', e.g. latMax,lonMin;latMin,lonMax. Polygons are specified with consecutive vertex coordinates separated by ';', e.g. lat1,lon1;lat2,lon2;lat3,lon3;... ",
            "required": false,
            "type": "string"
          },
          {
            "name": "arrival",
            "in": "query",
            "description": "Format like departure. Use this to find out when you have to start the journey to arrive at the given time. Note that toll cost is not considered when arrival time is specified.",
            "required": false,
            "type": "string"
          },
          {
            "name": "rollups",
            "in": "query",
            "description": "Comma separated list of rollups (groupings, aggregation levels) in the result. Currently supported rollups are none (per link details), total (totals), tollsys (per toll system summaries), country (per country summaries), country;tollsys (per country and toll system summaries). Example: &rollups=none,country;tollsys,country returns the cost details and 2 different summaries.",
            "required": false,
            "type": "string"
          },
          {
            "name": "speedFcCat",
            "in": "query",
            "description": "Comma separated list of speeds driven in kilometer per hour per road functional class (1-5 + Virtual Connections VC) and speed category (1-8) (f.e. FC1-SC1,FC1-SC2,...,FC1-SC8;FC2-SC1,FC2-SC2,...;...;VC-SC1,FC-SC2,...VC-SC8). Functional classes are semicolon separated. Can contain empty entries (no change to default f.e. 80,76,,,,,,;,,,54,46,,,;...). Overrides router's default driven speed values.",
            "required": false,
            "type": "string"
          },
          {
            "name": "routeAttributes",
            "in": "query",
            "description": "Defines which information is included in the response route part of the calculated route. Defaults to mode (mo), waypoints (wp), summary (sm), flags (fl). Also supported: speedProfile (sp), shape (sh), summaryByCountry (sc), boundinbBox (bb). Can be excluded in the response by putting a hyphen in the front. e.g. -wp",
            "required": false,
            "type": "string"
          },
          {
            "name": "responseAttributes",
            "in": "query",
            "description": "Defines which information is included in the response as part of the calculated route. Defaults to warnings (wn). Also supported: language (lg). Can be excluded in the response by putting a hyphen in the front. e.g. -wn",
            "required": false,
            "type": "string"
          },
          {
            "name": "maneuverAttributes",
            "in": "query",
            "description": "Defines which attributes are included in the response as part of the data representation of the route maneuvers. Defaults to position, instruction, length, travelTime. Additional values supported are direction and action.",
            "required": false,
            "type": "string"
          },
          {
            "name": "legAttributes",
            "in": "query",
            "description": "Defines which information is included in the response as part of the route legs. Defaults to links (li), maneuvers (mn), length (le), travelTime (tt), baseTime (bt), trafficTime (tm). Also supported: shape (sh), boundingBox (bb), turnbyturnmaneuvers (mm), none. Can be excluded in the response by putting a hyphen in the front. e.g. -mn",
            "required": false,
            "type": "string"
          },
          {
            "name": "linkAttributes",
            "in": "query",
            "description": "Define optional attributes to be returned for each link. Defaults to shape (sh), length (le), remainTime (rt), remainDistance (rd), functionalClass (fc), warnings (wn), confidence (cd). Also supported: cost (co), maneuver (ma), timezone (tz), none. Can be excluded in the response by putting a hyphen in the front. e.g. -ma",
            "required": false,
            "type": "string"
          },
          {
            "name": "traverseGates",
            "in": "query",
            "description": "Assume the driver has keys/permissions to traverse gates, if \"true\". Default = don't traverse any gates unless vehicle type is emergency.",
            "required": false,
            "type": "string"
          },
          {
            "name": "routeMatch",
            "in": "query",
            "description": "Default: Compute a legal route that goes through all way points. 1 = treat the waypoints (or trace file POST body) as GPS trace and return the most probable route along this trace. 2 = ETA Tracking mode, compute the route and take the POST body GPS trace into account to detect taken driver rest times and reached/skipped waypoints.",
            "required": false,
            "type": "string"
          },
          {
            "name": "legal",
            "in": "query",
            "description": "For routeMatch=1. Enforces a legal route w.r.t. the listed maneuver types. Support maneuver types (comma separated list): access,gate,oneway,thrutraf,turn. Passing all of them yields a legal route as from a router. access=use only links allowed for the vehicle type (incl. truck measures). gate=don't traverse gates. oneway=don't drive links into forbidden direction. thrutraf=don't enter+leaving 'no through traffic' zones. turn=don't turn/u-turn illegally. Default: avoid illegal maneuvers, but use them if the trace obviously used them. If used, return respective warnings.",
            "required": false,
            "type": "string"
          },
          {
            "name": "attributes",
            "in": "query",
            "description": "Comma separated list of PDE layer names, to get link attributes along the route. Only link attribute layers (roughly those ending in _FC1, _FC2 ... ) are supported. Specify FCn to get the layers of all functional classes. Behind each layer name attributes can be listed, or (*) to get all. Example: &attributes=ROAD_GEOM_FCn(TUNNEL), SPEED_LIMITS_FCn (FROM_REF_SPEED_LIMIT, TO_REF_SPEED_LIMIT), ADAS_ATTRIB_FCn (SLOPES). A maximum of 32 layers can be requested per request.",
            "required": false,
            "type": "string"
          },
          {
            "name": "tollPass",
            "in": "query",
            "description": "Comma separated list of owned passes: Senior_Pass, transponder, Annual, Nr_of_Days, Nr_of_Months, SunPass, E-Z Pass (last 2 are examples for real toll transponders). Allows traversal of 'transponder-only' toll booths and allows cost free traversal of certain toll sections.",
            "required": false,
            "type": "string"
          },
          {
            "name": "capacity",
            "in": "query",
            "description": "Comma separated list of numeric truck capacity limits. E.g. 8,25,6 for max. 8t payload and max. 25 square meter floor space and max 6 passengers. Must match the 'load' values of way points. For unsorted or optional way points.",
            "required": false,
            "type": "string"
          },
          {
            "name": "customConsumptionDetails",
            "in": "query",
            "description": "Semicolon separated list of speed/ascent/descent/builtupFactor/auxilliaryConsumption fuel consumption parameters. Speed is a list of $/km for different speeds. Ascent/descent are additional $/km per altitude climbed or descended. Builtup factor is an optional heuristic consumption multiplier for urban area, default value is 1.55. auxilliaryConsumption is the additional consumption (per hour) for running auxilliary units (climate control, infotainment, lights, etc.). Cost unit is not $ but 'currency'. Example: speed,0,0.102,10,0.084,30,0.066,50,0.06,70,0.066,100,0.072,120,0.084,140,0.108; ascent,0.4; descent,0.1; builtupFactor,1.4 = at 70 kph the car consumes 6.6$/100km and 0.4$/km altitude climbed, consumption increases 40% in urban area. Alternatively, user can specify default consumption profile: 3.5t, 7.5t, 18t, 40t or weightDependent. In case of the weightDependent consumption profiles will be decided based on the limitedWeight so this parameter also needs to be specified.",
            "required": false,
            "type": "string"
          },
          {
            "name": "alternatives",
            "in": "query",
            "description": "Maximum number of alternative route options to return. Can return less or no alternatives. Only returns route alternatives that significantly differ from the best route but are not much more costly.",
            "required": false,
            "type": "string"
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "Routing calculation must be finished within this amount of milliseconds. Default 50000. Maximum 50000.",
            "required": false,
            "type": "string"
          },
          {
            "name": "ignoreWaypointVehicleRestriction",
            "in": "query",
            "description": "radius[;penaltyFactor[;all]] Radius in meter around a waypoint to ignore restrictions (vehicle type, admin truck, time-based) restrictions if necessary. Penalty factor (cost multiplier 0...1) how strict to avoid. all = not only time based restrictions.",
            "required": false,
            "type": "string"
          },
          {
            "name": "maxSpeed",
            "in": "query",
            "description": "Maximum speed allowed for the whole routing. Supported units are kmh (kilometres per hour), mph (miles per hour) and mps (metres per second). If no unit is provided, kmh will be used as default unit.",
            "required": false,
            "type": "string"
          },
          {
            "name": "alignToGpsTime",
            "in": "query",
            "description": "Route matching tries to align the driving time to the GPS timestamps. On per default. Set to 0 to switch it off.",
            "required": false,
            "type": "string"
          },
          {
            "name": "customAttributes",
            "in": "query",
            "description": "Comma separated list of CLE layer names, to get link attributes along the route. Format follows the 'attribute' parameter. No FCn notation supported",
            "required": false,
            "type": "string"
          },
          {
            "name": "mapMatchRadius",
            "in": "query",
            "description": "Map match search radius [meter]. Will be applied to each way point. If given it overrides waypoints' transitRadius values. Default 100.0.",
            "required": false,
            "type": "string"
          },
          {
            "name": "excludeCountries",
            "in": "query",
            "description": "excludeCountries",
            "required": false,
            "type": "string"
          },
          {
            "name": "excludeZoneTypes",
            "in": "query",
            "description": "Checks if a route may enter a zone. Currently supported values: environmental. If omitted or empty, zone restrictions are not taken into account. Not supported for route matching.",
            "required": false,
            "type": "string"
          },
          {
            "name": "requestId",
            "in": "query",
            "description": "Mirrored RequestId value from the request structure. Used to trace requests.",
            "required": false,
            "type": "string"
          },
          {
            "name": "instructionFormat",
            "in": "query",
            "description": "Defines the representation format of the maneuver's instruction text. Supported formats are text|html",
            "required": false,
            "type": "string"
          },
          {
            "name": "oneway",
            "in": "query",
            "description": "Default: Obey oneways. 'penalty:0.5' allows oneway violation if the time benefit is more than 0.5 sec/meter. For bicycle recommended value 0.125, for emergencies 0.5. Not allowed for other vehicles.",
            "required": false,
            "type": "string"
          },
          {
            "name": "drivingReport",
            "in": "query",
            "description": "Defines whether driving report is added to the route match response. Set to 1 to switch it on. Turned off by default.",
            "required": false,
            "type": "string"
          },
          {
            "name": "ignorePreferredRoutes",
            "in": "query",
            "description": "Preferred routes for a specific vehicle type, are taken by default. To turn if off set ignorePreferredRoutes to true.",
            "required": false,
            "type": "string"
          },
          {
            "name": "avoidTurns",
            "in": "query",
            "description": "Comma separated list of elements like left[;minAngleDegree;penaltySec] or right... or uTurn[;penaltySec] if a left/right turn is sharper than the specified angle (0...180) then the given time penalty is applied. uTurnAtWaypoint avoids u-turning on the link directly where the waypoint was reached.",
            "required": false,
            "type": "string"
          },
          {
            "name": "ignoreZeroSpeedPoints",
            "in": "query",
            "description": "Only for route matching. Default = consider all points. 1 = ignore trace points that have zero speed (only in traces that provide speed but not time).",
            "required": false,
            "type": "string"
          },
          {
            "name": "chargingStationFilters",
            "in": "query",
            "description": "URL Encoded comma separated list of charging stations to filter out the electric vehicle charging stations, along the route.",
            "required": false,
            "type": "string"
          },
          {
            "name": "makeReachable",
            "in": "query",
            "description": "A route will be returned even there are not sufficient fuel/EV-charging stations along the route consumption/energy details if this parameter is set to true. Default = false.",
            "required": false,
            "type": "string"
          },
          {
            "name": "cellularSignals",
            "in": "query",
            "description": "cellularSignals",
            "required": false,
            "type": "string"
          },
          {
            "name": "plannedWaypointReachTolerance",
            "in": "query",
            "description": "Only for routeMatch=2 with learned stops. Default = 20000 meter. If the trace gets closer then the learned stop is considered reached",
            "required": false,
            "type": "string"
          },
          {
            "name": "customRestrLimit",
            "in": "query",
            "description": "Comma separated list of key value pairs of custom restriction limits. The key and value of individual custom restriction limit must be numeric and must be separated by colon. Example: 0:10,1:20,2:50",
            "required": false,
            "type": "string"
          },
          {
            "name": "evPoiLayer",
            "in": "query",
            "description": "Name of the layer which will be used to find the Electric Charging Stations along the route for Electric Vehicle Routing",
            "required": false,
            "type": "string"
          },
          {
            "name": "routeMatch2PlannedWayPointReachRadius",
            "in": "query",
            "description": "Only for routeMatch=2. If vehicle apporaches a planned waypoint closer than this then the waypoint is considered reached. Default 20000.0m.",
            "required": false,
            "type": "string"
          },
          {
            "name": "ignoreWaypointsFarFromNeighbors",
            "in": "query",
            "description": "Only for routeMatch>0. Default true. If false then doesn't ignore a trace point when it is much further away from its neighbors than the usual distances in the trace",
            "required": false,
            "type": "string"
          },
          {
            "name": "wayPointHeadingMismatchPenaltyFactor",
            "in": "query",
            "description": "Tie waypoints closer to links where the GPS heading matches the link's heading, and try harder to meet waypoints in the given driving direction. Default = 1.",
            "required": false,
            "type": "string"
          },
          {
            "name": "avoidPrivate",
            "in": "query",
            "description": "Use private streets for routing. Set to 1 to always allow it or -1 to always forbid it. Default is 0 - access is allowed if there is a waypoint in the private street.",
            "required": false,
            "type": "string"
          },
          {
            "name": "licensePlate",
            "in": "query",
            "description": "Licenseplate of the vehicle. The vehicles registration number can influence the permission to drive in certain zones, mostly environmental zones.",
            "required": false,
            "type": "string"
          },
          {
            "name": "adminTruckRestrictions",
            "in": "query",
            "description": "Per default admin wide truck restrictions are obeyed. 'ignore' ignores them.",
            "required": false,
            "type": "string"
          },
          {
            "name": "mapMatchTolerance",
            "in": "query",
            "description": "Map match tolerance [meter]. Will be applied to each way point. Routing can meet the waypoint on all links that are that much further away from the coordinate than the nearest. Default 3.0.",
            "required": false,
            "type": "string"
          },
          {
            "name": "privateChargingStation",
            "in": "query",
            "description": "If true then private charging stations will be considered during routing. Default is false.",
            "required": false,
            "type": "string"
          },
          {
            "name": "costPerConsumptionUnit",
            "in": "query",
            "description": "The cost of a consumption unit in targetCurrency. Default is 1.",
            "required": false,
            "type": "string"
          },
          {
            "name": "restTimeDriverCost",
            "in": "query",
            "description": "Cost per hour in target currency while driver is taking a legal rest time. Can be between 0 and driver_cost value.",
            "required": false,
            "type": "string"
          },
          {
            "name": "waypoint0 ... waypointN",
            "in": "query",
            "description": "Comma separated waypoint latitude, longitude in WGS-84 degree. A route must consist of at least 2\r\nwaypoints (start and destination). The maximum number of waypoints is limited. However, this limit is not a fixed number but is a result of the limit for the overall processing time.\r\nSet a transit radius by ;10000 to only influence the route to go via a certain city\r\nSet a heading by ;;;140 (degree clockwise from North) to improve map matching\r\nTo define a loading/delay time at a waypoint, use stopOver[,timeInSeconds]!. Example: &waypoint1=stopOver,300!50.12,8.65.\r\nThe optional specifications altitude, custom label, !StreetPosition and !LinkPosition are currently supported.\r\nThe coordinates may be directly followed by ;transitRadius;label;heading.\r\nWaypoints can have opening and closing times, can be unsorted or optional. Details are in Key Concepts / Waypoint sorting, optional Pickup and Opening Times",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "file",
            "description": "Trace file for route matching. GPX, NMEA, KML or CSV.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "jsonCallback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/Response"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      },
      "post": {
        "tags": [
          "Routing & Route Matching"
        ],
        "summary": "Calculates a route with additional fleet telematics features",
        "description": "Calculates a route with additional fleet telematics features.\r\nThis resource provides a similar interface as the Routing REST API.\r\nNote: If using the cre.api.here.com endpoint, then requests that don't need specific features may get redirected to the Routing REST API. This doesn't happen when usgin the fleet.api.here.com endpoint.",
        "operationId": "calculateRouteUsingPOST",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8",
          "multipart/form-data"
        ],
        "parameters": [
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": false,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "description": "app_code",
            "required": false,
            "type": "string"
          },
          {
            "name": "driver_cost",
            "in": "query",
            "description": "Cost per hour in target currency.",
            "required": false,
            "type": "string"
          },
          {
            "name": "vehicle_cost",
            "in": "query",
            "description": "Cost per kilometer in target currency.",
            "required": false,
            "type": "string"
          },
          {
            "name": "vehicleCostOnFerry",
            "in": "query",
            "description": "Cost per kilometer on ferry in target currency.",
            "required": false,
            "type": "string"
          },
          {
            "name": "currency",
            "in": "query",
            "description": "3 letter ISO currency symbol, like EUR or USD. Required if toll cost must be added up across different currencies and/or be added to driver/vehicle/fuel cost in different currencies.",
            "required": false,
            "type": "string"
          },
          {
            "name": "region",
            "in": "query",
            "description": "Optional (default=whole world excl. JPN, CHN, SK). Map coverage region, e.g. APAC, AUS, WEU, IND, MEA, NA, SAM, TWN, JPN. The region may contain hints to distinguish specific content. E.g. there can be an WEU and PCBEU, where the 2nd map contains only Postal Code Boundary layers. If not specified, the service will find the region(s) automatically, that cover the request. The parameter can contain a comma separated list of regions (f.e. WEU,MEA). If the region parameter is specified, the service will use these region(s) and skip region(s) that may also cover the response (f.e. EEU). Except of JPN, specifying a region is strongly discouraged, because regions might change and hence applications that specify a region might stop working when the region gets discontinued, renamed, split or changed otherwise. As the APAC region contains a simplified entry map content of JPN, JPN needs to be specified as region to access the full JPN content.",
            "required": false,
            "type": "string"
          },
          {
            "name": "departure",
            "in": "query",
            "description": "Format: now, yyyy-MM-dd'T'HH:mm:ss or yyyy-MM-dd'T'HH:mm:ssX. If no timezone is specified, then the local timezone at the route start link is used. Default: Ignore all time dependent access restrictions. Special values: ignoreTimeDepRestr (like default), obeyTimeDepRestr (all time dependent restrictions apply).",
            "required": false,
            "type": "string"
          },
          {
            "name": "tollVehicleType",
            "in": "query",
            "description": "1=Motorcycle, 2=Auto, 3=Truck, 4=Motor home, 5=Minibus, 6=Bus, 7=Motorcycle Sidecar(EU), 8=Tricycle(EU), 9=Delivery Truck(EU+India), 10=Snowmobile(US), 11=Pick-up(US+India), 12=Tractor(US+India), 13=Taxi, 14=HCM/EME (India)",
            "required": false,
            "type": "string"
          },
          {
            "name": "trailerType",
            "in": "query",
            "description": "0=None, 1=Caravan, 2=Trailer. For toll cost.",
            "required": false,
            "type": "string"
          },
          {
            "name": "trailersCount",
            "in": "query",
            "description": "Number of trailers, 0...4. For toll cost and truck restrictions. 0=no trailer, 1=one or more trailers, 2=two or more trailers, 3=three or more trailers. For truck restrictions: 4=one or more semi-trailers.",
            "required": false,
            "type": "string"
          },
          {
            "name": "vehicleNumberAxles",
            "in": "query",
            "description": "Number of axles excluding trailers. For toll cost and for country wide truck restrictions.",
            "required": false,
            "type": "string"
          },
          {
            "name": "trailerNumberAxles",
            "in": "query",
            "description": "Number of trailer axles. For toll cost and for country wide truck restrictions.",
            "required": false,
            "type": "string"
          },
          {
            "name": "hybrid",
            "in": "query",
            "description": "1=fuel+electric, 0=otherwise. For toll cost.",
            "required": false,
            "type": "string"
          },
          {
            "name": "emissionType",
            "in": "query",
            "description": "1=EURO I, 2=EURO II, 3=EURO III, 4=EURO IV, 5=EURO V, 6=EURO VI, 7=EURO EEV, 8=Electric Vehicles. For toll cost and environmental zone restrictions.",
            "required": false,
            "type": "string"
          },
          {
            "name": "height",
            "in": "query",
            "description": "350cm or 3.5m or 138in. For truck restrictions and toll cost.",
            "required": false,
            "type": "string"
          },
          {
            "name": "trailerHeight",
            "in": "query",
            "description": "350cm or 3.5m or 138in. For toll cost.",
            "required": false,
            "type": "string"
          },
          {
            "name": "vehicleWeight",
            "in": "query",
            "description": "Actual total weight of vehicle incl. payload, but not trailers' weight or payload. 7.5t or 7500kg or 16500lbs. See also limitedWeight. For toll cost.",
            "required": false,
            "type": "string"
          },
          {
            "name": "limitedWeight",
            "in": "query",
            "description": "Actual total weight of vehicle incl. payload and trailers/caravan incl. their payload. 7.5t or 7500kg or 16500lbs. For truck restrictions, speed profile, toll cost and environmental zone restrictions. See also vehicleWeight.",
            "required": false,
            "type": "string"
          },
          {
            "name": "disabledEquipped",
            "in": "query",
            "description": "1=vehicle equipped to carry disabled people, 0=otherwise. For toll cost.",
            "required": false,
            "type": "string"
          },
          {
            "name": "passengersCount",
            "in": "query",
            "description": "actual number of passengers. For toll cost. See also vehicle type carHOV.",
            "required": false,
            "type": "string"
          },
          {
            "name": "tiresCount",
            "in": "query",
            "description": "Number of tires. For toll cost.",
            "required": false,
            "type": "string"
          },
          {
            "name": "commercial",
            "in": "query",
            "description": "1=vehicle registered for commercial use, 0=otherwise. For toll cost and environmental zone regulations.",
            "required": false,
            "type": "string"
          },
          {
            "name": "shippedHazardousGoods",
            "in": "query",
            "description": "Comma separated list from explosive, gas, flammable, combustible, organic, poison, radioActive, corrosive, poisonousInhalation, harmfulToWater, other, allhazardousGoods, explosiveFlammable. For toll cost (only explosive and other) and for truck restrictions.",
            "required": false,
            "type": "string"
          },
          {
            "name": "heightAbove1stAxle",
            "in": "query",
            "description": "350cm or 3.5m or 138in. For toll cost.",
            "required": false,
            "type": "string"
          },
          {
            "name": "length",
            "in": "query",
            "description": "350cm or 3.5m or 138in. For truck restrictions and toll cost.",
            "required": false,
            "type": "string"
          },
          {
            "name": "trailerWeight",
            "in": "query",
            "description": "Actual total weight of trailers with their payload. 7.5t or 7500kg or 16500lbs. See also limitedWeight. For toll cost.",
            "required": false,
            "type": "string"
          },
          {
            "name": "weightPerAxle",
            "in": "query",
            "description": "Actual total weight per axle, incl. payload. 7.5t or 7500kg or 16500lbs. For toll cost and truck restrictions.",
            "required": false,
            "type": "string"
          },
          {
            "name": "width",
            "in": "query",
            "description": "350cm or 3.5m or 138in. For truck restrictions.",
            "required": false,
            "type": "string"
          },
          {
            "name": "tunnelCategory",
            "in": "query",
            "description": "Defines the tunnel categories the truck must NOT use. B, C, D or E. A tunnels have no restrictions. E tunnels have most restrictions. If C is defined, the route will use A and B tunnels but not C, D or E.",
            "required": false,
            "type": "string"
          },
          {
            "name": "fuelType",
            "in": "query",
            "description": "Defines the fuel powering the vehicle. Can be Diesel, Petrol, LPG, LNG, CNG, Ethanol, Propane, Hydrogen, Electric. (LPG=Liquefied Petroleum Gas,  LNG=Liquefied Natural Gas). Used f.e. for environmental zone restrictions, toll cost calculation, consumption based routing for Electric vehicles.",
            "required": false,
            "type": "string"
          },
          {
            "name": "weightPerAxleGroup",
            "in": "query",
            "description": "Semicolon separated list of vehicle weight [tons] per axle group. Each item is a tupel (name,value). Supported names are single,and tandem. Example: &weightPerAxleGroup=single:12;tandem:18",
            "required": false,
            "type": "string"
          },
          {
            "name": "overlays",
            "in": "query",
            "description": "Overlay map name. Case insensitive. Must start with OVERLAY and contain only characters.",
            "required": false,
            "type": "string"
          },
          {
            "name": "mode",
            "in": "query",
            "description": "fastest;car;traffic:disabled;[optional parameters] As optional parameters motorway (0, -1, -2, -3), tollroad (0, -1, -2, -3), boatFerry (0, -1, -2, -3), railFerry (0, -1, -2, -3), and tunnel (0, -1, -2, -3) can follow. \"shortest\" and \"balanced\" are not supported but can be individually tuned using &driver_cost and &vehicle_cost. Vehicle types: bdouble, bicycle, bus, car, carHOV, custom1, emergency, motorcycle, pedestrian, roadtrain, taxi, truck",
            "required": false,
            "type": "string"
          },
          {
            "name": "restTimes",
            "in": "query",
            "description": "Legal drive/rest intervals. Specify 'local' to obey the legal driver rest times of the respective country. If the driver is not fresh then add ,TimeAlreadyDrivenSinceLastShortBreak,TimeAlreadyDrivenSinceLastLongRest in seconds. Alternatively, proprietary values can be set for DriveTimeUntilShortBreak, ElapsedTimeUntilShortBreak, ShortBreakDuration, DriveTimeUntilLongRest, ElapsedTimeUntilLongBreak, LongRestDuration. E.g. EU requires after 4.5h a 45min break + after 9h an 11h rest.",
            "required": false,
            "type": "string"
          },
          {
            "name": "language",
            "in": "query",
            "description": "Language for the maneuver instructions in the response. Currently de-de, en-us and it-it are supported. If not specified, en-us is used.",
            "required": false,
            "type": "string"
          },
          {
            "name": "avoidLinks",
            "in": "query",
            "description": "Comma separated list of link ids to be avoided. Positive ids are not driven from reference node, negative ids are not driven towards reference node. Use '*' prefix to avoid both directions.",
            "required": false,
            "type": "string"
          },
          {
            "name": "avoidAreas",
            "in": "query",
            "description": "List of areas (rectangles or polygons) to be avoided. Areas are separated by '!'. Rectangles can be specified with two diagonal coordinates separated by ';', e.g. latMax,lonMin;latMin,lonMax. Polygons are specified with consecutive vertex coordinates separated by ';', e.g. lat1,lon1;lat2,lon2;lat3,lon3;... ",
            "required": false,
            "type": "string"
          },
          {
            "name": "arrival",
            "in": "query",
            "description": "Format like departure. Use this to find out when you have to start the journey to arrive at the given time. Note that toll cost is not considered when arrival time is specified.",
            "required": false,
            "type": "string"
          },
          {
            "name": "rollups",
            "in": "query",
            "description": "Comma separated list of rollups (groupings, aggregation levels) in the result. Currently supported rollups are none (per link details), total (totals), tollsys (per toll system summaries), country (per country summaries), country;tollsys (per country and toll system summaries). Example: &rollups=none,country;tollsys,country returns the cost details and 2 different summaries.",
            "required": false,
            "type": "string"
          },
          {
            "name": "speedFcCat",
            "in": "query",
            "description": "Comma separated list of speeds driven in kilometer per hour per road functional class (1-5 + Virtual Connections VC) and speed category (1-8) (f.e. FC1-SC1,FC1-SC2,...,FC1-SC8;FC2-SC1,FC2-SC2,...;...;VC-SC1,FC-SC2,...VC-SC8). Functional classes are semicolon separated. Can contain empty entries (no change to default f.e. 80,76,,,,,,;,,,54,46,,,;...). Overrides router's default driven speed values.",
            "required": false,
            "type": "string"
          },
          {
            "name": "routeAttributes",
            "in": "query",
            "description": "Defines which information is included in the response route part of the calculated route. Defaults to mode (mo), waypoints (wp), summary (sm), flags (fl). Also supported: speedProfile (sp), shape (sh), summaryByCountry (sc), boundinbBox (bb). Can be excluded in the response by putting a hyphen in the front. e.g. -wp",
            "required": false,
            "type": "string"
          },
          {
            "name": "responseAttributes",
            "in": "query",
            "description": "Defines which information is included in the response as part of the calculated route. Defaults to warnings (wn). Also supported: language (lg). Can be excluded in the response by putting a hyphen in the front. e.g. -wn",
            "required": false,
            "type": "string"
          },
          {
            "name": "maneuverAttributes",
            "in": "query",
            "description": "Defines which attributes are included in the response as part of the data representation of the route maneuvers. Defaults to position, instruction, length, travelTime. Additional values supported are direction and action.",
            "required": false,
            "type": "string"
          },
          {
            "name": "legAttributes",
            "in": "query",
            "description": "Defines which information is included in the response as part of the route legs. Defaults to links (li), maneuvers (mn), length (le), travelTime (tt), baseTime (bt), trafficTime (tm). Also supported: shape (sh), boundingBox (bb), turnbyturnmaneuvers (mm), none. Can be excluded in the response by putting a hyphen in the front. e.g. -mn",
            "required": false,
            "type": "string"
          },
          {
            "name": "linkAttributes",
            "in": "query",
            "description": "Define optional attributes to be returned for each link. Defaults to shape (sh), length (le), remainTime (rt), remainDistance (rd), functionalClass (fc), warnings (wn), confidence (cd). Also supported: cost (co), maneuver (ma), timezone (tz), none. Can be excluded in the response by putting a hyphen in the front. e.g. -ma",
            "required": false,
            "type": "string"
          },
          {
            "name": "traverseGates",
            "in": "query",
            "description": "Assume the driver has keys/permissions to traverse gates, if \"true\". Default = don't traverse any gates unless vehicle type is emergency.",
            "required": false,
            "type": "string"
          },
          {
            "name": "routeMatch",
            "in": "query",
            "description": "Default: Compute a legal route that goes through all way points. 1 = treat the waypoints (or trace file POST body) as GPS trace and return the most probable route along this trace. 2 = ETA Tracking mode, compute the route and take the POST body GPS trace into account to detect taken driver rest times and reached/skipped waypoints.",
            "required": false,
            "type": "string"
          },
          {
            "name": "legal",
            "in": "query",
            "description": "For routeMatch=1. Enforces a legal route w.r.t. the listed maneuver types. Support maneuver types (comma separated list): access,gate,oneway,thrutraf,turn. Passing all of them yields a legal route as from a router. access=use only links allowed for the vehicle type (incl. truck measures). gate=don't traverse gates. oneway=don't drive links into forbidden direction. thrutraf=don't enter+leaving 'no through traffic' zones. turn=don't turn/u-turn illegally. Default: avoid illegal maneuvers, but use them if the trace obviously used them. If used, return respective warnings.",
            "required": false,
            "type": "string"
          },
          {
            "name": "attributes",
            "in": "query",
            "description": "Comma separated list of PDE layer names, to get link attributes along the route. Only link attribute layers (roughly those ending in _FC1, _FC2 ... ) are supported. Specify FCn to get the layers of all functional classes. Behind each layer name attributes can be listed, or (*) to get all. Example: &attributes=ROAD_GEOM_FCn(TUNNEL), SPEED_LIMITS_FCn (FROM_REF_SPEED_LIMIT, TO_REF_SPEED_LIMIT), ADAS_ATTRIB_FCn (SLOPES). A maximum of 32 layers can be requested per request.",
            "required": false,
            "type": "string"
          },
          {
            "name": "tollPass",
            "in": "query",
            "description": "Comma separated list of owned passes: Senior_Pass, transponder, Annual, Nr_of_Days, Nr_of_Months, SunPass, E-Z Pass (last 2 are examples for real toll transponders). Allows traversal of 'transponder-only' toll booths and allows cost free traversal of certain toll sections.",
            "required": false,
            "type": "string"
          },
          {
            "name": "capacity",
            "in": "query",
            "description": "Comma separated list of numeric truck capacity limits. E.g. 8,25,6 for max. 8t payload and max. 25 square meter floor space and max 6 passengers. Must match the 'load' values of way points. For unsorted or optional way points.",
            "required": false,
            "type": "string"
          },
          {
            "name": "customConsumptionDetails",
            "in": "query",
            "description": "Semicolon separated list of speed/ascent/descent/builtupFactor/auxilliaryConsumption fuel consumption parameters. Speed is a list of $/km for different speeds. Ascent/descent are additional $/km per altitude climbed or descended. Builtup factor is an optional heuristic consumption multiplier for urban area, default value is 1.55. auxilliaryConsumption is the additional consumption (per hour) for running auxilliary units (climate control, infotainment, lights, etc.). Cost unit is not $ but 'currency'. Example: speed,0,0.102,10,0.084,30,0.066,50,0.06,70,0.066,100,0.072,120,0.084,140,0.108; ascent,0.4; descent,0.1; builtupFactor,1.4 = at 70 kph the car consumes 6.6$/100km and 0.4$/km altitude climbed, consumption increases 40% in urban area. Alternatively, user can specify default consumption profile: 3.5t, 7.5t, 18t, 40t or weightDependent. In case of the weightDependent consumption profiles will be decided based on the limitedWeight so this parameter also needs to be specified.",
            "required": false,
            "type": "string"
          },
          {
            "name": "alternatives",
            "in": "query",
            "description": "Maximum number of alternative route options to return. Can return less or no alternatives. Only returns route alternatives that significantly differ from the best route but are not much more costly.",
            "required": false,
            "type": "string"
          },
          {
            "name": "timeout",
            "in": "query",
            "description": "Routing calculation must be finished within this amount of milliseconds. Default 50000. Maximum 50000.",
            "required": false,
            "type": "string"
          },
          {
            "name": "ignoreWaypointVehicleRestriction",
            "in": "query",
            "description": "radius[;penaltyFactor[;all]] Radius in meter around a waypoint to ignore restrictions (vehicle type, admin truck, time-based) restrictions if necessary. Penalty factor (cost multiplier 0...1) how strict to avoid. all = not only time based restrictions.",
            "required": false,
            "type": "string"
          },
          {
            "name": "maxSpeed",
            "in": "query",
            "description": "Maximum speed allowed for the whole routing. Supported units are kmh (kilometres per hour), mph (miles per hour) and mps (metres per second). If no unit is provided, kmh will be used as default unit.",
            "required": false,
            "type": "string"
          },
          {
            "name": "alignToGpsTime",
            "in": "query",
            "description": "Route matching tries to align the driving time to the GPS timestamps. On per default. Set to 0 to switch it off.",
            "required": false,
            "type": "string"
          },
          {
            "name": "customAttributes",
            "in": "query",
            "description": "Comma separated list of CLE layer names, to get link attributes along the route. Format follows the 'attribute' parameter. No FCn notation supported",
            "required": false,
            "type": "string"
          },
          {
            "name": "mapMatchRadius",
            "in": "query",
            "description": "Map match search radius [meter]. Will be applied to each way point. If given it overrides waypoints' transitRadius values. Default 100.0.",
            "required": false,
            "type": "string"
          },
          {
            "name": "excludeCountries",
            "in": "query",
            "description": "excludeCountries",
            "required": false,
            "type": "string"
          },
          {
            "name": "excludeZoneTypes",
            "in": "query",
            "description": "Checks if a route may enter a zone. Currently supported values: environmental. If omitted or empty, zone restrictions are not taken into account. Not supported for route matching.",
            "required": false,
            "type": "string"
          },
          {
            "name": "requestId",
            "in": "query",
            "description": "Mirrored RequestId value from the request structure. Used to trace requests.",
            "required": false,
            "type": "string"
          },
          {
            "name": "instructionFormat",
            "in": "query",
            "description": "Defines the representation format of the maneuver's instruction text. Supported formats are text|html",
            "required": false,
            "type": "string"
          },
          {
            "name": "oneway",
            "in": "query",
            "description": "Default: Obey oneways. 'penalty:0.5' allows oneway violation if the time benefit is more than 0.5 sec/meter. For bicycle recommended value 0.125, for emergencies 0.5. Not allowed for other vehicles.",
            "required": false,
            "type": "string"
          },
          {
            "name": "drivingReport",
            "in": "query",
            "description": "Defines whether driving report is added to the route match response. Set to 1 to switch it on. Turned off by default.",
            "required": false,
            "type": "string"
          },
          {
            "name": "ignorePreferredRoutes",
            "in": "query",
            "description": "Preferred routes for a specific vehicle type, are taken by default. To turn if off set ignorePreferredRoutes to true.",
            "required": false,
            "type": "string"
          },
          {
            "name": "avoidTurns",
            "in": "query",
            "description": "Comma separated list of elements like left[;minAngleDegree;penaltySec] or right... or uTurn[;penaltySec] if a left/right turn is sharper than the specified angle (0...180) then the given time penalty is applied. uTurnAtWaypoint avoids u-turning on the link directly where the waypoint was reached.",
            "required": false,
            "type": "string"
          },
          {
            "name": "ignoreZeroSpeedPoints",
            "in": "query",
            "description": "Only for route matching. Default = consider all points. 1 = ignore trace points that have zero speed (only in traces that provide speed but not time).",
            "required": false,
            "type": "string"
          },
          {
            "name": "chargingStationFilters",
            "in": "query",
            "description": "URL Encoded comma separated list of charging stations to filter out the electric vehicle charging stations, along the route.",
            "required": false,
            "type": "string"
          },
          {
            "name": "makeReachable",
            "in": "query",
            "description": "A route will be returned even there are not sufficient fuel/EV-charging stations along the route consumption/energy details if this parameter is set to true. Default = false.",
            "required": false,
            "type": "string"
          },
          {
            "name": "cellularSignals",
            "in": "query",
            "description": "cellularSignals",
            "required": false,
            "type": "string"
          },
          {
            "name": "plannedWaypointReachTolerance",
            "in": "query",
            "description": "Only for routeMatch=2 with learned stops. Default = 20000 meter. If the trace gets closer then the learned stop is considered reached",
            "required": false,
            "type": "string"
          },
          {
            "name": "customRestrLimit",
            "in": "query",
            "description": "Comma separated list of key value pairs of custom restriction limits. The key and value of individual custom restriction limit must be numeric and must be separated by colon. Example: 0:10,1:20,2:50",
            "required": false,
            "type": "string"
          },
          {
            "name": "evPoiLayer",
            "in": "query",
            "description": "Name of the layer which will be used to find the Electric Charging Stations along the route for Electric Vehicle Routing",
            "required": false,
            "type": "string"
          },
          {
            "name": "routeMatch2PlannedWayPointReachRadius",
            "in": "query",
            "description": "Only for routeMatch=2. If vehicle apporaches a planned waypoint closer than this then the waypoint is considered reached. Default 20000.0m.",
            "required": false,
            "type": "string"
          },
          {
            "name": "ignoreWaypointsFarFromNeighbors",
            "in": "query",
            "description": "Only for routeMatch>0. Default true. If false then doesn't ignore a trace point when it is much further away from its neighbors than the usual distances in the trace",
            "required": false,
            "type": "string"
          },
          {
            "name": "wayPointHeadingMismatchPenaltyFactor",
            "in": "query",
            "description": "Tie waypoints closer to links where the GPS heading matches the link's heading, and try harder to meet waypoints in the given driving direction. Default = 1.",
            "required": false,
            "type": "string"
          },
          {
            "name": "avoidPrivate",
            "in": "query",
            "description": "Use private streets for routing. Set to 1 to always allow it or -1 to always forbid it. Default is 0 - access is allowed if there is a waypoint in the private street.",
            "required": false,
            "type": "string"
          },
          {
            "name": "licensePlate",
            "in": "query",
            "description": "Licenseplate of the vehicle. The vehicles registration number can influence the permission to drive in certain zones, mostly environmental zones.",
            "required": false,
            "type": "string"
          },
          {
            "name": "adminTruckRestrictions",
            "in": "query",
            "description": "Per default admin wide truck restrictions are obeyed. 'ignore' ignores them.",
            "required": false,
            "type": "string"
          },
          {
            "name": "mapMatchTolerance",
            "in": "query",
            "description": "Map match tolerance [meter]. Will be applied to each way point. Routing can meet the waypoint on all links that are that much further away from the coordinate than the nearest. Default 3.0.",
            "required": false,
            "type": "string"
          },
          {
            "name": "privateChargingStation",
            "in": "query",
            "description": "If true then private charging stations will be considered during routing. Default is false.",
            "required": false,
            "type": "string"
          },
          {
            "name": "costPerConsumptionUnit",
            "in": "query",
            "description": "The cost of a consumption unit in targetCurrency. Default is 1.",
            "required": false,
            "type": "string"
          },
          {
            "name": "restTimeDriverCost",
            "in": "query",
            "description": "Cost per hour in target currency while driver is taking a legal rest time. Can be between 0 and driver_cost value.",
            "required": false,
            "type": "string"
          },
          {
            "name": "waypoint0 ... waypointN",
            "in": "query",
            "description": "Comma separated waypoint latitude, longitude in WGS-84 degree. A route must consist of at least 2\r\nwaypoints (start and destination). The maximum number of waypoints is limited. However, this limit is not a fixed number but is a result of the limit for the overall processing time.\r\nSet a transit radius by ;10000 to only influence the route to go via a certain city\r\nSet a heading by ;;;140 (degree clockwise from North) to improve map matching\r\nTo define a loading/delay time at a waypoint, use stopOver[,timeInSeconds]!. Example: &waypoint1=stopOver,300!50.12,8.65.\r\nThe optional specifications altitude, custom label, !StreetPosition and !LinkPosition are currently supported.\r\nThe coordinates may be directly followed by ;transitRadius;label;heading.\r\nWaypoints can have opening and closing times, can be unsorted or optional. Details are in Key Concepts / Waypoint sorting, optional Pickup and Opening Times",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "file",
            "description": "Trace file for route matching. GPX, NMEA, KML or CSV.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "jsonCallback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/Response"
            }
          },
          "201": {
            "description": "Created"
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/2/calculaterouteisoline.json": {
      "get": {
        "tags": [
          "Routing & Route Matching"
        ],
        "summary": "Return the links within an time/distance isoline along the route",
        "description": "The route is specified by a ROUTE_ID or by waypoints. See calculateroute.json for a description of the parameters.",
        "operationId": "calculateRouteIsolineUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8"
        ],
        "parameters": [
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "description": "app_code",
            "required": false,
            "type": "string"
          },
          {
            "name": "route_id",
            "in": "query",
            "description": "route_id",
            "required": false,
            "type": "string"
          },
          {
            "name": "max_detour_distance",
            "in": "query",
            "description": "Maximum driving distance in meters from the route path. This is one way, from the junction that leaves the route until to the map object. The distance to get back onto the route is not considered here. Either distance or time limit must be specified.",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "max_detour_time",
            "in": "query",
            "description": "Maximum driving time in seconds from the route path. This is one way, from the junction that leaves the route until to the map object. The time to get back onto the route is not considered here. Either distance or time limit must be specified.",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "geom",
            "in": "query",
            "description": "geom",
            "required": false,
            "type": "string",
            "default": "local",
            "enum": [
              "local",
              "full",
              "none"
            ]
          },
          {
            "name": "region",
            "in": "query",
            "description": "Optional (default=whole world excl. JPN, CHN, SK). Map coverage region, e.g. APAC, AUS, WEU, IND, MEA, NA, SAM, TWN, JPN. The region may contain hints to distinguish specific content. E.g. there can be an WEU and PCBEU, where the 2nd map contains only Postal Code Boundary layers. If not specified, the service will find the region(s) automatically, that cover the request. The parameter can contain a comma separated list of regions (f.e. WEU,MEA). If the region parameter is specified, the service will use these region(s) and skip region(s) that may also cover the response (f.e. EEU). Except of JPN, specifying a region is strongly discouraged, because regions might change and hence applications that specify a region might stop working when the region gets discontinued, renamed, split or changed otherwise. As the APAC region contains a simplified entry map content of JPN, JPN needs to be specified as region to access the full JPN content.",
            "required": false,
            "type": "string"
          },
          {
            "name": "language",
            "in": "query",
            "description": "language",
            "required": false,
            "type": "string"
          },
          {
            "name": "departure",
            "in": "query",
            "description": "departure",
            "required": false,
            "type": "string"
          },
          {
            "name": "trailerType",
            "in": "query",
            "description": "trailerType",
            "required": false,
            "type": "string"
          },
          {
            "name": "trailersCount",
            "in": "query",
            "description": "trailersCount",
            "required": false,
            "type": "string"
          },
          {
            "name": "vehicleNumberAxles",
            "in": "query",
            "description": "vehicleNumberAxles",
            "required": false,
            "type": "string"
          },
          {
            "name": "trailerNumberAxles",
            "in": "query",
            "description": "trailerNumberAxles",
            "required": false,
            "type": "string"
          },
          {
            "name": "hybrid",
            "in": "query",
            "description": "hybrid",
            "required": false,
            "type": "string"
          },
          {
            "name": "emissionType",
            "in": "query",
            "description": "emissionType",
            "required": false,
            "type": "string"
          },
          {
            "name": "height",
            "in": "query",
            "description": "height",
            "required": false,
            "type": "string"
          },
          {
            "name": "trailerHeight",
            "in": "query",
            "description": "trailerHeight",
            "required": false,
            "type": "string"
          },
          {
            "name": "vehicleWeight",
            "in": "query",
            "description": "vehicleWeight",
            "required": false,
            "type": "string"
          },
          {
            "name": "limitedWeight",
            "in": "query",
            "description": "limitedWeight",
            "required": false,
            "type": "string"
          },
          {
            "name": "disabledEquipped",
            "in": "query",
            "description": "disabledEquipped",
            "required": false,
            "type": "string"
          },
          {
            "name": "minimalPollution",
            "in": "query",
            "description": "minimalPollution",
            "required": false,
            "type": "string"
          },
          {
            "name": "hov",
            "in": "query",
            "description": "hov",
            "required": false,
            "type": "string"
          },
          {
            "name": "passengersCount",
            "in": "query",
            "description": "passengersCount",
            "required": false,
            "type": "string"
          },
          {
            "name": "tiresCount",
            "in": "query",
            "description": "tiresCount",
            "required": false,
            "type": "string"
          },
          {
            "name": "commercial",
            "in": "query",
            "description": "commercial",
            "required": false,
            "type": "string"
          },
          {
            "name": "shippedHazardousGoods",
            "in": "query",
            "description": "shippedHazardousGoods",
            "required": false,
            "type": "string"
          },
          {
            "name": "heightAbove1stAxle",
            "in": "query",
            "description": "heightAbove1stAxle",
            "required": false,
            "type": "string"
          },
          {
            "name": "mode",
            "in": "query",
            "description": "Specifies whether shortest or fastest route shall be computed, for which vehicle type (car, truck,...) and whether traffic information shall be used. Example fastest;car;traffic:disabled See calculateroute.json for details.",
            "required": false,
            "type": "string"
          },
          {
            "name": "linkAttributes",
            "in": "query",
            "description": "Define optional attributes to be returned for each link. Defaults to shape, length, remainTime, remainDistance, flags. Also supported: cost",
            "required": false,
            "type": "string"
          },
          {
            "name": "responseAttributes",
            "in": "query",
            "description": "Defines which information is included in the response as part of the calculated route isoline. Defaults to warnings (wn). Can be excluded in the response by putting a hyphen in the front. e.g. -wn",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/GeometrySearchResponse"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/2/doc/maps.json": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "List the available custom maps",
        "operationId": "mapsJSONUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8"
        ],
        "parameters": [
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "description": "app_code",
            "required": false,
            "type": "string"
          },
          {
            "name": "map_name",
            "in": "query",
            "description": "Optional. Restrict the search to return only the info on this map. Default: All maps of this app_id.",
            "required": false,
            "type": "string"
          },
          {
            "name": "public_maps",
            "in": "query",
            "description": "Optional. If '1' then the public maps are also listed.",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/MapDocResponse"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/2/layers/access/grant.json": {
      "get": {
        "tags": [
          "Upload Data"
        ],
        "summary": "Grant other app_ids Access to Geometry Layers",
        "operationId": "grantPermissionUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "layer_id",
            "in": "query",
            "description": "name of layer for which to grant access",
            "required": false,
            "type": "string"
          },
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "granted_app_id",
            "in": "query",
            "description": "Other app_id that will get access to the layer",
            "required": false,
            "type": "string"
          },
          {
            "name": "permissions",
            "in": "query",
            "description": "Comma separated list containing read, write and/or export. read allows searches on the layer (except all.json or all.txt), write allows uploading or modifying the layer and export allows all searches. Regardless of the previous permissions, the granted_app_id replaces these access rights. An empty list revokes all permissions.",
            "required": false,
            "type": "string"
          },
          {
            "name": "map_name",
            "in": "query",
            "description": "set the permissions for the layer in this map, default = set the permissions for the layer in app_id's default map",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LayerPermissionResponse"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/2/layers/delete.json": {
      "get": {
        "tags": [
          "Upload Data"
        ],
        "summary": "Delete some of my Geometry Layers",
        "operationId": "deleteLayersUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "layer_ids",
            "in": "query",
            "description": "Comma separated list of layers to delete",
            "required": false,
            "type": "string"
          },
          {
            "name": "map_name",
            "in": "query",
            "description": "delete the layers within this map, default = delete the layers in app_id's default map",
            "required": false,
            "type": "string"
          },
          {
            "name": "storage",
            "in": "query",
            "description": "Either updatable or readonly. Default = both.",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DeleteLayersResponse"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/2/layers/list.json": {
      "get": {
        "tags": [
          "Search",
          "Upload Data"
        ],
        "summary": "List custom geometry Layers",
        "operationId": "listUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "storage",
            "in": "query",
            "description": "Either updatable or readonly. Default = both.",
            "required": false,
            "type": "string"
          },
          {
            "name": "map_name",
            "in": "query",
            "description": "show only the layers of this map, default = show the layers of all maps",
            "required": false,
            "type": "string"
          },
          {
            "name": "public_maps",
            "in": "query",
            "description": "Optional. if '1' then the public HERE map layers are listed as well.",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ListLayersResponse"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/2/layers/modify.json": {
      "get": {
        "tags": [
          "Upload Data"
        ],
        "summary": "Modify Geometries in Existing Layers",
        "description": "Modify geometries using an HTTP GET or POST request. After the response there is a delay of several seconds to compile, store and make the modified geometries available in the service.\r\nNote: The level (tile grid size) of the layer can only be changed by uploading the whole layer, not as a modification operation.",
        "operationId": "modifyGetUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "changes",
            "in": "query",
            "description": "For GET requests: URL-encoded WKT file content as parameter value. For POST requests: Instead of this parameter, a multipart/form-data body is sent. The supported file formats and the parameter name are the same as for upload.json.",
            "required": false,
            "type": "string"
          },
          {
            "name": "layer_id",
            "in": "query",
            "description": "name of layer to modify",
            "required": false,
            "type": "string"
          },
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "action",
            "in": "query",
            "description": "append, update or delete. Geometries are identified by their geometry_id column value. For append, the geometries must not exist yet and will be added. For update, the geometries must exist and will be replaced. All column values must be specified, not only the changes. For update and delete, the columns must not change - names, sequence orders and type must be identical. For delete, the geometries must exist and will be replaced. Only the geometry_id column is required.",
            "required": false,
            "type": "string"
          },
          {
            "name": "wkt_quote",
            "in": "query",
            "description": "Specify the quote character to use. Default = \" (double quotes). Specifying NONE disables quotes.",
            "required": false,
            "type": "string",
            "default": "\""
          },
          {
            "name": "map_name",
            "in": "query",
            "description": "update the layer in this map, default = update the layer within the app_id's default map",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LayerModifyResponse"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          },
          "409": {
            "description": "Modify Conflict",
            "schema": {
              "$ref": "#/definitions/LayerModifyResponse"
            }
          }
        }
      },
      "post": {
        "tags": [
          "Upload Data"
        ],
        "summary": "Modify Geometries in Existing Layers",
        "description": "Modify geometries using an HTTP GET or POST request. After the response there is a delay of several seconds to compile, store and make the modified geometries available in the service.\r\nNote: The level (tile grid size) of the layer can only be changed by uploading the whole layer, not as a modification operation.",
        "operationId": "modifyPostUsingPOST",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "layer_id",
            "in": "query",
            "description": "name of layer to modify",
            "required": false,
            "type": "string"
          },
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "action",
            "in": "query",
            "description": "append, update or delete. Geometries are identified by their geometry_id column value. For append, the geometries must not exist yet and will be added. For update, the geometries must exist and will be replaced. All column values must be specified, not only the changes. For update and delete, the columns must not change - names, sequence orders and type must be identical. For delete, the geometries must exist and will be replaced. Only the geometry_id column is required.",
            "required": false,
            "type": "string"
          },
          {
            "name": "map_name",
            "in": "query",
            "description": "update the layer in this map, default = update the layer within the app_id's default map",
            "required": false,
            "type": "string"
          },
          {
            "name": "wkt_quote",
            "in": "query",
            "description": "Specify the quote character to use. Default = \" (double quotes). Specifying NONE disables quotes.",
            "required": false,
            "type": "string",
            "default": "\""
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LayerModifyResponse"
            }
          },
          "201": {
            "description": "Created"
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          },
          "409": {
            "description": "Modify Conflict",
            "schema": {
              "$ref": "#/definitions/LayerModifyResponse"
            }
          }
        }
      }
    },
    "/2/layers/upload.json": {
      "get": {
        "tags": [
          "Upload Data"
        ],
        "summary": "Import Geometries in a WKT or Shape File",
        "description": "Import polygons, polylines or points in WKT (Wellknown Text) or Shapefile format geometries using an HTTP POST request, or import WKT geometries using HTTP GET. A layer can contain only one geometry type - polygons, polylines or points, but not a mix of different types. After the response there is a delay of several seconds to compile, store and make the geometries available in the service.",
        "operationId": "uploadGetUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "file",
            "in": "query",
            "description": "For GET requests: URL-encoded WKT file content as parameter value. For POST requests: Instead of this parameter, a multipart/form-data body is sent. The filename of the multipart entity is arbitrary. The file can be a plain or zipped WKT text file ending with .wkt, or a zipped archive containing a .shp, .shx and .dbf file (optionally .prj or .cpg files). A WKT file consists of TAB separated elements. The first line contains the column names, the last column must be \"wkt\". The subsequent lines contain the content, the attributes and the geometry. To create an index on a set of columns for faster all.json responses, append ;* to these column names.",
            "required": false,
            "type": "string"
          },
          {
            "name": "layer_id",
            "in": "query",
            "description": "name of layer to create/replace",
            "required": false,
            "type": "string"
          },
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "level",
            "in": "query",
            "description": "Specify tile size for the database for performance optimization",
            "required": false,
            "type": "integer",
            "default": 12,
            "format": "int32"
          },
          {
            "name": "storage",
            "in": "query",
            "description": "Either updatable or readonly. Default = updatable.",
            "required": false,
            "type": "string",
            "default": "updatable"
          },
          {
            "name": "wkt_quote",
            "in": "query",
            "description": "Specify the quote character to use. Default = \" (double quotes). Specifying NONE disables quotes.",
            "required": false,
            "type": "string",
            "default": "\""
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "map_name",
            "in": "query",
            "description": "upload the layer into this map, default = upload the layer into the app_id's default map",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LayerUploadResponse"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      },
      "post": {
        "tags": [
          "Upload Data"
        ],
        "summary": "Import Geometries in a WKT or Shape File",
        "description": "Import polygons, polylines or points in WKT (Wellknown Text) or Shapefile format geometries using an HTTP POST request, or import WKT geometries using HTTP GET. A layer can contain only one geometry type - polygons, polylines or points, but not a mix of different types. After the response there is a delay of several seconds to compile, store and make the geometries available in the service.",
        "operationId": "uploadPostUsingPOST",
        "consumes": [
          "multipart/form-data"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "layer_id",
            "in": "query",
            "description": "name of layer to create/replace",
            "required": false,
            "type": "string"
          },
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "level",
            "in": "query",
            "description": "Specify tile size for the database for performance optimization",
            "required": false,
            "type": "integer",
            "default": 12,
            "format": "int32"
          },
          {
            "name": "storage",
            "in": "query",
            "description": "Either updatable or readonly. Default = updatable.",
            "required": false,
            "type": "string",
            "default": "updatable"
          },
          {
            "name": "wkt_quote",
            "in": "query",
            "description": "Specify the quote character to use. Default = \" (double quotes). Specifying NONE disables quotes.",
            "required": false,
            "type": "string",
            "default": "\""
          },
          {
            "name": "map_name",
            "in": "query",
            "description": "upload the layer into this map, default = upload the layer into the app_id's default map",
            "required": false,
            "type": "string"
          },
          {
            "in": "body",
            "name": "file",
            "description": "WKT file content",
            "required": true,
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LayerUploadResponse"
            }
          },
          "201": {
            "description": "Created"
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/2/maps/delete.json": {
      "get": {
        "tags": [
          "Upload Data"
        ],
        "summary": "Delete one of my Maps",
        "operationId": "deleteMapsUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "map_name",
            "in": "query",
            "description": "name of map to delete",
            "required": false,
            "type": "string"
          },
          {
            "name": "storage",
            "in": "query",
            "description": "Either updatable or readonly. Default = both.",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DeleteLayersResponse"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/2/overlays/upload.json": {
      "get": {
        "tags": [
          "Upload Data"
        ],
        "summary": "Submit an overlay map for customized routing.",
        "description": "Submit an overlay map with custom modifications, such as block road links, remove restrictions from road links, or insert new road links into the network. The modifications that you submit, as part of your overlay maps, are only visible to you but not to other customers. Also, these modifications are not uploaded to the official HERE map. Routing can consider overlay maps.",
        "operationId": "submitPostUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "overlay_spec",
            "in": "query",
            "description": "mandatory (unless in POST body). string. JSON structure describing the map changes.",
            "required": false,
            "type": "string"
          },
          {
            "name": "point_order_obeys_one_ways",
            "in": "query",
            "description": "optional. true/false. If true then geometry is not matched onto links if it is against the legal driving direction.",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "multidigitized_handling",
            "in": "query",
            "description": "multidigitized_handling",
            "required": false,
            "type": "string"
          },
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": false,
            "type": "string"
          },
          {
            "name": "storage",
            "in": "query",
            "description": "optional. string. Currently only readonly is supported.",
            "required": false,
            "type": "string",
            "default": "readonly"
          },
          {
            "name": "map_name",
            "in": "query",
            "description": "mandatory. string. Overlay map name. Case insensitive. Must start with OVERLAY and contain only characters.",
            "required": false,
            "type": "string"
          },
          {
            "name": "private_link_handling",
            "in": "query",
            "description": "optional. string. Three values are supported: PLAIN = normal behavior (default), UNCONNECTED = don't connect new links to existing private links (use to avoid connecting new links to an unrelated neighboring facility), DROPEXISTING = block the existing private links (use if an existing link overlaps with a new link and is less",
            "required": false,
            "type": "string"
          },
          {
            "name": "max_distance_to_match",
            "in": "query",
            "description": "optional. number. Specifies how many meters apart the geometries of two new links can be, to establish a connection. Should not exceed a few meters.",
            "required": false,
            "type": "string"
          },
          {
            "name": "max_distance_to_connect",
            "in": "query",
            "description": "optional. number. Specifies how many meters apart the geometries of a new link and an existing link can be, to establish connection. Should not exceed a few meters.",
            "required": false,
            "type": "string"
          },
          {
            "name": "min_match_confidence",
            "in": "query",
            "description": "optional, default 0.6. 0.0 ... 1.0. Specify the minimum required road match confidence level. If a match is below this level, the service throws an error.",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "optional. string. Specifies the name of a user-defined function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "fullTable",
            "in": "query",
            "description": "optional, default 'true'. Set to 'false' if the layer upload response time is too big otherwise. If 'false' then /search/all.json will not work on this layer.",
            "required": false,
            "type": "string",
            "default": "true"
          },
          {
            "name": "max_match_search_distance",
            "in": "query",
            "description": "optional. number. Default 100 meter. Specifies how many meters around a given point to search for existing geometries. Should not exceed a few meters.",
            "required": false,
            "type": "string"
          },
          {
            "name": "matchMode",
            "in": "query",
            "description": "optional. 0 or 1. Default 0. 0 does sophisticated geometry match. 1 does a quicker check which is usually sufficient if the geometries fit exactly to the existing road network.",
            "required": false,
            "type": "string"
          },
          {
            "name": "parent_overlay",
            "in": "query",
            "description": "parent_overlay",
            "required": false,
            "type": "string"
          },
          {
            "name": "id_space_offset",
            "in": "query",
            "description": "id_space_offset",
            "required": false,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/OverlaySubmitResponse"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      },
      "post": {
        "tags": [
          "Upload Data"
        ],
        "summary": "Submit an overlay map for customized routing.",
        "description": "Submit an overlay map with custom modifications, such as block road links, remove restrictions from road links, or insert new road links into the network. The modifications that you submit, as part of your overlay maps, are only visible to you but not to other customers. Also, these modifications are not uploaded to the official HERE map. Routing can consider overlay maps.",
        "operationId": "submitPostUsingPOST",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "overlay_spec",
            "in": "query",
            "description": "mandatory (unless in POST body). string. JSON structure describing the map changes.",
            "required": false,
            "type": "string"
          },
          {
            "name": "point_order_obeys_one_ways",
            "in": "query",
            "description": "optional. true/false. If true then geometry is not matched onto links if it is against the legal driving direction.",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "multidigitized_handling",
            "in": "query",
            "description": "multidigitized_handling",
            "required": false,
            "type": "string"
          },
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": false,
            "type": "string"
          },
          {
            "name": "storage",
            "in": "query",
            "description": "optional. string. Currently only readonly is supported.",
            "required": false,
            "type": "string",
            "default": "readonly"
          },
          {
            "name": "map_name",
            "in": "query",
            "description": "mandatory. string. Overlay map name. Case insensitive. Must start with OVERLAY and contain only characters.",
            "required": false,
            "type": "string"
          },
          {
            "name": "private_link_handling",
            "in": "query",
            "description": "optional. string. Three values are supported: PLAIN = normal behavior (default), UNCONNECTED = don't connect new links to existing private links (use to avoid connecting new links to an unrelated neighboring facility), DROPEXISTING = block the existing private links (use if an existing link overlaps with a new link and is less",
            "required": false,
            "type": "string"
          },
          {
            "name": "max_distance_to_match",
            "in": "query",
            "description": "optional. number. Specifies how many meters apart the geometries of two new links can be, to establish a connection. Should not exceed a few meters.",
            "required": false,
            "type": "string"
          },
          {
            "name": "max_distance_to_connect",
            "in": "query",
            "description": "optional. number. Specifies how many meters apart the geometries of a new link and an existing link can be, to establish connection. Should not exceed a few meters.",
            "required": false,
            "type": "string"
          },
          {
            "name": "min_match_confidence",
            "in": "query",
            "description": "optional, default 0.6. 0.0 ... 1.0. Specify the minimum required road match confidence level. If a match is below this level, the service throws an error.",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "optional. string. Specifies the name of a user-defined function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "fullTable",
            "in": "query",
            "description": "optional, default 'true'. Set to 'false' if the layer upload response time is too big otherwise. If 'false' then /search/all.json will not work on this layer.",
            "required": false,
            "type": "string",
            "default": "true"
          },
          {
            "name": "max_match_search_distance",
            "in": "query",
            "description": "optional. number. Default 100 meter. Specifies how many meters around a given point to search for existing geometries. Should not exceed a few meters.",
            "required": false,
            "type": "string"
          },
          {
            "name": "matchMode",
            "in": "query",
            "description": "optional. 0 or 1. Default 0. 0 does sophisticated geometry match. 1 does a quicker check which is usually sufficient if the geometries fit exactly to the existing road network.",
            "required": false,
            "type": "string"
          },
          {
            "name": "parent_overlay",
            "in": "query",
            "description": "parent_overlay",
            "required": false,
            "type": "string"
          },
          {
            "name": "id_space_offset",
            "in": "query",
            "description": "id_space_offset",
            "required": false,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "required": true,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/OverlaySubmitResponse"
            }
          },
          "201": {
            "description": "Created"
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/2/search/all.json": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "Search for custom geometries by attribute filter, or download complete layer.",
        "operationId": "searchAllUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8"
        ],
        "parameters": [
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "layer_id",
            "in": "query",
            "description": "Layer ID identifying the layers to be searched. Can also be a comma separated list of layers. Layer names are not case sensitive. The maximum length of a layer name and the permitted characters can be looked up up in the service via /serviceconfiguration.json",
            "required": false,
            "type": "string"
          },
          {
            "name": "filter",
            "in": "query",
            "description": "A JavaScript expression being evaluated for each geometry matching search query.\r\nColumns value for the geometry are available as defined variables.\r\nWhen specified, only geometries where expression evaluates to true will be returned.\r\nExample: filter=RATING > 3 && NAME != 'MyPlace23' && NAME.startsWith('Food')\r\nParameter value must be url encoded when using special characters.\r\nThis filter expression is applied after the spatial filtering, hence only to few geometries. Only for the all.json the filter is applied to all geometries, so it can become very slow for big layers. Hence, following substring search expressions use database indexes and are much faster than other filter expressions (for updatable layers):\r\nCOL_NAME.indexOf(\"my_substring\") >= 0\r\nCOL_NAME.startsWith(\"my_prefix\")\r\nCOL_NAME == \"str\"\r\nCOL_NAME === \"str\"\r\nCOL_NAME != \"str\"\r\nCOL_NAME !== \"str\"\r\nCOL_NAME.indexOf(\"str\") >= 0\r\nCOL_NAME.startsWith(\"str\")\r\nCOL_NAME.like(\"%str%\")\r\nTo avoid service overload, filter expressions must not exceed 100 characters of text and their execution on the result must not exceed 100 ms execution time.",
            "required": false,
            "type": "string"
          },
          {
            "name": "searchtext",
            "in": "query",
            "description": "Free text search with fault tolerance for custom layers and attributes. This is supported only for updatable layers if it was configured when the layer was created.",
            "required": false,
            "type": "string"
          },
          {
            "name": "geom",
            "in": "query",
            "description": "full or none. Specifies the geometry representation in the result. Default = full. Full geometry is used for interactive editing, where the original geometry is required. None is used for applications like geofencing, which most of the time want to know only the ids of the geofence points/lines polygons they are in or near.",
            "required": false,
            "type": "string",
            "default": "full",
            "enum": [
              "local",
              "full",
              "none"
            ]
          },
          {
            "name": "start_geometry_id",
            "in": "query",
            "description": "To paginate huge responses, this parameter specifies the lowest geometry id to be returned. If geometry ids are not known, then retrieve the first page using zero, and to retrieve subsequent pages then request highest geometry of current page + 1 (it doesn't matter whether this geometry id actually exists or not). Use this parameter together with no_of_records.\r\nParameter can be a single value that applies to all layers, or a comma separated list equal in number to the number of layers specified in layer_id parameter.",
            "required": false,
            "type": "string"
          },
          {
            "name": "no_of_records",
            "in": "query",
            "description": "The number of geometries in the response. If more geometries satisfy the search/filter criteria, they will be suppressed. It is undefined, which of the matching geometries are returned, unless this parameter is used together with start_geometry_id, which sorts the results set by geometry id.\r\nParameter can be a single value that applies to all layers, or a comma separated list equal in number to the number of layers specified in layer_id parameter.\r\nThe maximum number of records supported within a single request can be looked up in the /serviceconfiguration.json endpoint.",
            "required": false,
            "type": "string"
          },
          {
            "name": "map_name",
            "in": "query",
            "description": "Optional. Map within to look for the layer. Default: Look into the default map.",
            "required": false,
            "type": "string"
          },
          {
            "name": "meta",
            "in": "query",
            "description": "Send with value=1 to get the response geometries framed with meta information like layer and tile id. Default = no meta data.",
            "required": false,
            "type": "string"
          },
          {
            "name": "acceptMissingLayers",
            "in": "query",
            "description": "Optional. If this parameter is set to true, user will get list of geometries from available layers, even if some of the requested layers are missing. If none of the requested layers are found, service returns empty list.",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/GeometrySearchResponse"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/2/search/bbox.json": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "Search for geometries in a given rectangle within custom layers",
        "operationId": "searchBoundingBoxUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8"
        ],
        "parameters": [
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": false,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "description": "app_code",
            "required": false,
            "type": "string"
          },
          {
            "name": "layer_id",
            "in": "query",
            "description": "Layer ID identifying the layers to be searched. Layer names are not case sensitive. The maximum length of a layer name and the permitted characters can be looked up up in the service via /serviceconfiguration.json",
            "required": false,
            "type": "string"
          },
          {
            "name": "bbox",
            "in": "query",
            "description": "The bounding box upper, left, lower and right coordinates in WGS84 degrees. All geometries overlapping this rectangle will be returned.\r\nThe format is latitude,longitude;latitude,longitude.\r\nExample: bbox=37.8,-122.1;37.2,-122.0",
            "required": false,
            "type": "string"
          },
          {
            "name": "filter",
            "in": "query",
            "description": "A JavaScript expression being evaluated for each geometry matching search query.\r\nColumns value for the geometry are available as defined variables.\r\nWhen specified, only geometries where expression evaluates to true will be returned.\r\nExample: filter=RATING > 3 && NAME != 'MyPlace23' && NAME.startsWith('Food')\r\nParameter value must be url encoded when using special characters.\r\nThis filter expression is applied after the spatial filtering, hence only to few geometries. Only for the all.json the filter is applied to all geometries, so it can become very slow for big layers. Hence, following substring search expressions use database indexes and are much faster than other filter expressions (for updatable layers):\r\nCOL_NAME.indexOf(\"my_substring\") >= 0\r\nCOL_NAME.startsWith(\"my_prefix\")\r\nCOL_NAME == \"str\"\r\nCOL_NAME === \"str\"\r\nCOL_NAME != \"str\"\r\nCOL_NAME !== \"str\"\r\nCOL_NAME.indexOf(\"str\") >= 0\r\nCOL_NAME.startsWith(\"str\")\r\nCOL_NAME.like(\"%str%\")\r\nTo avoid service overload, filter expressions must not exceed 100 characters of text and their execution on the result must not exceed 100 ms execution time.",
            "required": false,
            "type": "string"
          },
          {
            "name": "geom",
            "in": "query",
            "description": "local, full or none. Specifies the geometry representation in the result. Default = local. Local geometry is used for map display purposes, returning geometry pieces that cover the given search radius, bounding box or corridor polygon. Full geometry is used for interactive editing, where the original geometry is required. None is used for applications like geofencing, which most of the time want to know only the ids of the geofence points/lines polygons they are in or near.",
            "required": false,
            "type": "string",
            "default": "local",
            "enum": [
              "local",
              "full",
              "none"
            ]
          },
          {
            "name": "storage",
            "in": "query",
            "description": "Optional, default searches in both. Specify 'updatable' or 'readonly', how you uploaded the layer.",
            "required": false,
            "type": "string",
            "default": "updatable"
          },
          {
            "name": "map_name",
            "in": "query",
            "description": "Optional. Map within to look for the layer. Default: Look into the default map.",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/GeometrySearchResponse"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/2/search/corridor.json": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "Search for custom geometries within a polyline's corridor",
        "description": "The number of geometries in the response should not exceed 1000. Exceeding one of the limits results in an error response. If an application needs more results returned then please contact technical customer support to work on a solution to reduce this.",
        "operationId": "searchCorridorUsingGET_1",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8"
        ],
        "parameters": [
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "description": "app_code",
            "required": false,
            "type": "string"
          },
          {
            "name": "radius",
            "in": "query",
            "description": "The buffer search radius in meters. All geometries overlapping the corridor polygon will be returned. Maximum radius is 5000.0 meter.",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "layer_ids",
            "in": "query",
            "description": "Comma separated list of layer IDs to be searched. Layer names are not case sensitive. The maximum length of a layer name and the permitted characters can be looked up up in the service via /serviceconfiguration.json",
            "required": false,
            "type": "string"
          },
          {
            "name": "attributes",
            "in": "query",
            "description": "List of comma separated column names to specify which attributes shall appear in the result. Column names are not case sensitive. Default = all.",
            "required": false,
            "type": "string"
          },
          {
            "name": "filter",
            "in": "query",
            "description": "A JavaScript expression being evaluated for each geometry matching search query.\r\nColumns value for the geometry are available as defined variables.\r\nWhen specified, only geometries where expression evaluates to true will be returned.\r\nExample: filter=RATING > 3 && NAME != 'MyPlace23' && NAME.startsWith('Food')\r\nParameter value must be url encoded when using special characters.\r\nThis filter expression is applied after the spatial filtering, hence only to few geometries. Only for the all.json the filter is applied to all geometries, so it can become very slow for big layers. Hence, following substring search expressions use database indexes and are much faster than other filter expressions (for updatable layers):\r\nCOL_NAME.indexOf(\"my_substring\") >= 0\r\nCOL_NAME.startsWith(\"my_prefix\")\r\nCOL_NAME == \"str\"\r\nCOL_NAME === \"str\"\r\nCOL_NAME != \"str\"\r\nCOL_NAME !== \"str\"\r\nCOL_NAME.indexOf(\"str\") >= 0\r\nCOL_NAME.startsWith(\"str\")\r\nCOL_NAME.like(\"%str%\")\r\nTo avoid service overload, filter expressions must not exceed 100 characters of text and their execution on the result must not exceed 100 ms execution time.",
            "required": false,
            "type": "string"
          },
          {
            "name": "corridor",
            "in": "query",
            "description": "Either corridor or route_id is required.\r\nThe WGS84 degree coordinates of the polyline used as corridor center line.\r\nFor example:\r\nlatitude 1,longitude 1;latitude 2,longitude 2;...",
            "required": false,
            "type": "string"
          },
          {
            "name": "route_id",
            "in": "query",
            "description": "Either corridor or route_id is required.\r\nA route_id obtained from a previous Router call. This route_id will be turned into a corridor polyline.",
            "required": false,
            "type": "string"
          },
          {
            "name": "geom",
            "in": "query",
            "description": "local, full or none. Specifies the geometry representation in the result. Default = local. Local geometry is used for map display purposes, returning geometry pieces that cover the given search radius, bounding box or corridor polygon. Full geometry is used for interactive editing, where the original geometry is required. None is used for applications like geofencing, which most of the time want to know only the ids of the geofence points/lines polygons they are in or near.",
            "required": false,
            "type": "string",
            "default": "local",
            "enum": [
              "local",
              "full",
              "none"
            ]
          },
          {
            "name": "storage",
            "in": "query",
            "description": "Optional, default searches in both. Specify 'updatable' or 'readonly', how you uploaded the layer.",
            "required": false,
            "type": "string",
            "default": "updatable"
          },
          {
            "name": "map_name",
            "in": "query",
            "description": "Optional. Map within to look for the layer. Default: Look into the default map.",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/GeometrySearchResponse"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      },
      "post": {
        "tags": [
          "Search"
        ],
        "summary": "Search for custom geometries within a polyline's corridor",
        "description": "The number of geometries in the response should not exceed 1000. Exceeding one of the limits results in an error response. If an application needs more results returned then please contact technical customer support to work on a solution to reduce this.",
        "operationId": "searchCorridorUsingPOST",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8"
        ],
        "parameters": [
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "description": "app_code",
            "required": false,
            "type": "string"
          },
          {
            "name": "radius",
            "in": "query",
            "description": "The buffer search radius in meters. All geometries overlapping the corridor polygon will be returned. Maximum radius is 5000.0 meter.",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "layer_ids",
            "in": "query",
            "description": "Comma separated list of layer IDs to be searched. Layer names are not case sensitive. The maximum length of a layer name and the permitted characters can be looked up up in the service via /serviceconfiguration.json",
            "required": false,
            "type": "string"
          },
          {
            "name": "attributes",
            "in": "query",
            "description": "List of comma separated column names to specify which attributes shall appear in the result. Column names are not case sensitive. Default = all.",
            "required": false,
            "type": "string"
          },
          {
            "name": "filter",
            "in": "query",
            "description": "A JavaScript expression being evaluated for each geometry matching search query.\r\nColumns value for the geometry are available as defined variables.\r\nWhen specified, only geometries where expression evaluates to true will be returned.\r\nExample: filter=RATING > 3 && NAME != 'MyPlace23' && NAME.startsWith('Food')\r\nParameter value must be url encoded when using special characters.\r\nThis filter expression is applied after the spatial filtering, hence only to few geometries. Only for the all.json the filter is applied to all geometries, so it can become very slow for big layers. Hence, following substring search expressions use database indexes and are much faster than other filter expressions (for updatable layers):\r\nCOL_NAME.indexOf(\"my_substring\") >= 0\r\nCOL_NAME.startsWith(\"my_prefix\")\r\nCOL_NAME == \"str\"\r\nCOL_NAME === \"str\"\r\nCOL_NAME != \"str\"\r\nCOL_NAME !== \"str\"\r\nCOL_NAME.indexOf(\"str\") >= 0\r\nCOL_NAME.startsWith(\"str\")\r\nCOL_NAME.like(\"%str%\")\r\nTo avoid service overload, filter expressions must not exceed 100 characters of text and their execution on the result must not exceed 100 ms execution time.",
            "required": false,
            "type": "string"
          },
          {
            "name": "corridor",
            "in": "query",
            "description": "Either corridor or route_id is required.\r\nThe WGS84 degree coordinates of the polyline used as corridor center line.\r\nFor example:\r\nlatitude 1,longitude 1;latitude 2,longitude 2;...",
            "required": false,
            "type": "string"
          },
          {
            "name": "route_id",
            "in": "query",
            "description": "Either corridor or route_id is required.\r\nA route_id obtained from a previous Router call. This route_id will be turned into a corridor polyline.",
            "required": false,
            "type": "string"
          },
          {
            "name": "geom",
            "in": "query",
            "description": "local, full or none. Specifies the geometry representation in the result. Default = local. Local geometry is used for map display purposes, returning geometry pieces that cover the given search radius, bounding box or corridor polygon. Full geometry is used for interactive editing, where the original geometry is required. None is used for applications like geofencing, which most of the time want to know only the ids of the geofence points/lines polygons they are in or near.",
            "required": false,
            "type": "string",
            "default": "local",
            "enum": [
              "local",
              "full",
              "none"
            ]
          },
          {
            "name": "storage",
            "in": "query",
            "description": "Optional, default searches in both. Specify 'updatable' or 'readonly', how you uploaded the layer.",
            "required": false,
            "type": "string",
            "default": "updatable"
          },
          {
            "name": "map_name",
            "in": "query",
            "description": "Optional. Map within to look for the layer. Default: Look into the default map.",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/GeometrySearchResponse"
            }
          },
          "201": {
            "description": "Created"
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/2/search/proximity.json": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "Search for geometries within a radius around a given coordinate in custom layers",
        "operationId": "searchProximityUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8"
        ],
        "parameters": [
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "description": "app_code",
            "required": false,
            "type": "string"
          },
          {
            "name": "layer_ids",
            "in": "query",
            "description": "Comma separated list of layer IDs to be searched. Layer names are not case sensitive. The maximum length of a layer name and the permitted characters can be looked up up in the service via /serviceconfiguration.json",
            "required": false,
            "type": "string"
          },
          {
            "name": "proximity",
            "in": "query",
            "description": "The circular search area specified by center latitude, longitude [WGS84 degrees], radius [meter].\r\nAll geometries overlapping this circle will be returned, sorted by distance, closest first.\r\nExample: proximity=47.731,7.5549,100\r\nMultiple coordinate pairs can be passed as a semicolon separated list. For each of them, the layer_ids list is searched. If each coordinate pair is searched in a different set of layers, layer_ids contains a semicolon separated list of (comma separated list of) layers.",
            "required": false,
            "type": "string"
          },
          {
            "name": "attributes",
            "in": "query",
            "description": "List of comma separated column names to specify which attributes shall appear in the result. Column names are not case sensitive. Default = all.",
            "required": false,
            "type": "string"
          },
          {
            "name": "filter",
            "in": "query",
            "description": "A JavaScript expression being evaluated for each geometry matching search query.\r\nColumns value for the geometry are available as defined variables.\r\nWhen specified, only geometries where expression evaluates to true will be returned.\r\nExample: filter=RATING > 3 && NAME != 'MyPlace23' && NAME.startsWith('Food')\r\nParameter value must be url encoded when using special characters.\r\nThis filter expression is applied after the spatial filtering, hence only to few geometries. Only for the all.json the filter is applied to all geometries, so it can become very slow for big layers. Hence, following substring search expressions use database indexes and are much faster than other filter expressions (for updatable layers):\r\nCOL_NAME.indexOf(\"my_substring\") >= 0\r\nCOL_NAME.startsWith(\"my_prefix\")\r\nCOL_NAME == \"str\"\r\nCOL_NAME === \"str\"\r\nCOL_NAME != \"str\"\r\nCOL_NAME !== \"str\"\r\nCOL_NAME.indexOf(\"str\") >= 0\r\nCOL_NAME.startsWith(\"str\")\r\nCOL_NAME.like(\"%str%\")\r\nTo avoid service overload, filter expressions must not exceed 100 characters of text and their execution on the result must not exceed 100 ms execution time.",
            "required": false,
            "type": "string"
          },
          {
            "name": "geom",
            "in": "query",
            "description": "local, full or none. Specifies the geometry representation in the result. Default = local. Local geometry is used for map display purposes, returning geometry pieces that cover the given search radius, bounding box or corridor polygon. Full geometry is used for interactive editing, where the original geometry is required. None is used for applications like geofencing, which most of the time want to know only the ids of the geofence points/lines polygons they are in or near.",
            "required": false,
            "type": "string",
            "default": "local",
            "enum": [
              "local",
              "full",
              "none"
            ]
          },
          {
            "name": "storage",
            "in": "query",
            "description": "Optional, default searches in both. Specify 'updatable' or 'readonly', how you uploaded the layer.",
            "required": false,
            "type": "string",
            "default": "updatable"
          },
          {
            "name": "map_name",
            "in": "query",
            "description": "Optional. Map within to look for the layer. Default: Look into the default map.",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "release",
            "in": "query",
            "description": "To choose a specific snapshot of the weather archive layer, a UNIX timestamp (number of milliseconds since 1970) or a date in 2017-12-01T17:30:00+01:00 format can be passed.",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/GeometrySearchResponse"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/2/search/quadkey.json": {
      "get": {
        "tags": [
          "Search"
        ],
        "summary": "Retrieve custom layer content within a quadkey",
        "description": "Retrieve the layer content records within a given geo rectangle specified by a (standard WGS84 Mercator) quadkey in custom layers.",
        "operationId": "searchQuadKeyUsingGET_1",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8"
        ],
        "parameters": [
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "description": "app_code",
            "required": false,
            "type": "string"
          },
          {
            "name": "layer_id",
            "in": "query",
            "description": "Layer ID identifying the layers to be searched. Layer names are not case sensitive. The maximum length of a layer name and the permitted characters can be looked up up in the service via /serviceconfiguration.json",
            "required": false,
            "type": "string"
          },
          {
            "name": "quad_key",
            "in": "query",
            "description": "The quad key number of the map tile area to search from.",
            "required": false,
            "type": "string"
          },
          {
            "name": "filter",
            "in": "query",
            "description": "A JavaScript expression being evaluated for each geometry matching search query.\r\nColumns value for the geometry are available as defined variables.\r\nWhen specified, only geometries where expression evaluates to true will be returned.\r\nExample: filter=RATING > 3 && NAME != 'MyPlace23' && NAME.startsWith('Food')\r\nParameter value must be url encoded when using special characters.\r\nThis filter expression is applied after the spatial filtering, hence only to few geometries. Only for the all.json the filter is applied to all geometries, so it can become very slow for big layers. Hence, following substring search expressions use database indexes and are much faster than other filter expressions (for updatable layers):\r\nCOL_NAME.indexOf(\"my_substring\") >= 0\r\nCOL_NAME.startsWith(\"my_prefix\")\r\nCOL_NAME == \"str\"\r\nCOL_NAME === \"str\"\r\nCOL_NAME != \"str\"\r\nCOL_NAME !== \"str\"\r\nCOL_NAME.indexOf(\"str\") >= 0\r\nCOL_NAME.startsWith(\"str\")\r\nCOL_NAME.like(\"%str%\")\r\nTo avoid service overload, filter expressions must not exceed 100 characters of text and their execution on the result must not exceed 100 ms execution time.",
            "required": false,
            "type": "string"
          },
          {
            "name": "geom",
            "in": "query",
            "description": "local, full or none. Specifies the geometry representation in the result. Default = local. Local geometry is used for map display purposes, returning geometry pieces that cover the given search radius, bounding box or corridor polygon. Full geometry is used for interactive editing, where the original geometry is required. None is used for applications like geofencing, which most of the time want to know only the ids of the geofence points/lines polygons they are in or near.",
            "required": false,
            "type": "string",
            "default": "local",
            "enum": [
              "local",
              "full",
              "none"
            ]
          },
          {
            "name": "storage",
            "in": "query",
            "description": "Optional, default searches in both. Specify 'updatable' or 'readonly', how you uploaded the layer.",
            "required": false,
            "type": "string",
            "default": "updatable"
          },
          {
            "name": "map_name",
            "in": "query",
            "description": "Optional. Map within to look for the layer. Default: Look into the default map.",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/GeometrySearchResponse"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    },
    "/2/search/routeisoline.json": {
      "get": {
        "tags": [
          "Routing & Route Matching",
          "Search"
        ],
        "summary": "Retrieve the POIs that are reachable within a certain time or distance from the main route",
        "operationId": "searchRouteIsolineUsingGET",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json;charset=UTF-8"
        ],
        "parameters": [
          {
            "name": "app_id",
            "in": "query",
            "description": "app_id",
            "required": true,
            "type": "string"
          },
          {
            "name": "app_code",
            "in": "query",
            "description": "app_code",
            "required": false,
            "type": "string"
          },
          {
            "name": "layer_ids",
            "in": "query",
            "description": "Comma separated list of layer IDs to be searched. Layer names are not case sensitive. Both custom layers and PDE map layers are supported. PDE layers divided by functional class, like ROAD_GEOM_FC1 ... FC5 can be selected by N, e.g. ROAD_GEOM_FCN. Layers must have a LINK_ID column. If a customer doesn't have a LINK_ID column, customers can create it using the Geocoder, Reverse Geocoder or RME. The maximum length of a layer name and the permitted characters can be looked up up in the service via /serviceconfiguration.json",
            "required": false,
            "type": "string"
          },
          {
            "name": "attributes",
            "in": "query",
            "description": "List of comma separated column names to specify which attributes shall appear in the result. Column names are not case sensitive. Default = all.",
            "required": false,
            "type": "string"
          },
          {
            "name": "geom",
            "in": "query",
            "description": "local, full or none. Specifies the geometry representation in the result. Default = local. Local geometry is used for map display purposes, returning geometry pieces that cover the given search radius, bounding box or corridor polygon. Full geometry is used for interactive editing, where the original geometry is required. None is used for applications like geofencing, which most of the time want to know only the ids of the geofence points/lines polygons they are in or near.",
            "required": false,
            "type": "string",
            "default": "local",
            "enum": [
              "local",
              "full",
              "none"
            ]
          },
          {
            "name": "max_detour_distance",
            "in": "query",
            "description": "Either max_detour_distance or max_detour_time must be specified. Maximum travel distance in meter away from the route to reach the map object. This is one way, from the junction that leaves the route until to the map object. The distance to get back onto the route is not considered here.",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "max_detour_time",
            "in": "query",
            "description": "Either max_detour_time or max_detour_distance\tMaximum travel time in seconds away from the route to reach the map object. This is one way, from the junction that leaves the route until to the map object. The time to get back onto the route is not considered here.",
            "required": false,
            "type": "number",
            "format": "double"
          },
          {
            "name": "storage",
            "in": "query",
            "description": "Optional, default searches in both. Specify 'updatable' or 'readonly', how you uploaded the layer.",
            "required": false,
            "type": "string",
            "default": "updatable"
          },
          {
            "name": "region",
            "in": "query",
            "description": "Optional (default=whole world excl. JPN, CHN, SK). Map coverage region, e.g. APAC, AUS, WEU, IND, MEA, NA, SAM, TWN, JPN. The region may contain hints to distinguish specific content. E.g. there can be an WEU and PCBEU, where the 2nd map contains only Postal Code Boundary layers. If not specified, the service will find the region(s) automatically, that cover the request. The parameter can contain a comma separated list of regions (f.e. WEU,MEA). If the region parameter is specified, the service will use these region(s) and skip region(s) that may also cover the response (f.e. EEU). Except of JPN, specifying a region is strongly discouraged, because regions might change and hence applications that specify a region might stop working when the region gets discontinued, renamed, split or changed otherwise. As the APAC region contains a simplified entry map content of JPN, JPN needs to be specified as region to access the full JPN content.",
            "required": false,
            "type": "string"
          },
          {
            "name": "language",
            "in": "query",
            "description": "language",
            "required": false,
            "type": "string"
          },
          {
            "name": "map_name",
            "in": "query",
            "description": "Optional. Map within to look for the layer. Default: Look into the default map.",
            "required": false,
            "type": "string"
          },
          {
            "name": "callback",
            "in": "query",
            "description": "Specifies the function used to wrap the JSON response.",
            "required": false,
            "type": "string"
          },
          {
            "name": "linkAttributes",
            "in": "query",
            "description": "Define optional attributes to be returned for each link. Currently supported: cost.",
            "required": false,
            "type": "string"
          },
          {
            "name": "waypoint0 ... waypointN",
            "in": "query",
            "description": "Either waypoints or route_id must be specified. Comma separated waypoint latitude, longitude in WGS-84 degree. A route must consist of at least 2\r\nwaypoints (start and destination). The maximum number of waypoints is limited. However, this limit is\r\nnot a fixed number but is a result of the limit for the overall processing time. To define a loading/delay\r\ntime at a waypoint, use stopOver[,timeInSeconds]!. Example: &waypoint1=stopOver,300!50.12,8.65.\r\nNone of the optional specifications geo!, stopOver!, passThrough!, altitude,\r\ntransitRadius, custom label, heading, !StreetPosition, !LinkPosition are currently supported.",
            "required": true,
            "type": "string"
          },
          {
            "name": "trailerType, trailersCount, vehicleNumberAxles, trailerNumberAxles, hybrid, emissionType, height, trailerHeight, vehicleWeight, limitedWeight, disabledEquipped, minimalPollution, hov, passengersCount, tiresCount, commercial, shippedHazardousGoods, heightAbove1stAxle",
            "in": "query",
            "description": "Parameters to specify the vehicle. See calculateroute.json for details.",
            "required": true,
            "type": "string"
          },
          {
            "name": "apikey",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/GeometrySearchResponse"
            }
          },
          "401": {
            "description": "Unauthorized"
          },
          "403": {
            "description": "Forbidden"
          },
          "404": {
            "description": "Not Found"
          }
        }
      }
    }
  },
  "definitions": {
    "AttributeDocBean": {
      "type": "object",
      "properties": {
        "description": {
          "type": "string"
        },
        "layers": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "name": {
          "type": "string"
        }
      }
    },
    "BoundingBox": {
      "type": "object",
      "properties": {
        "bottomRight": {
          "$ref": "#/definitions/Coordinate"
        },
        "topLeft": {
          "$ref": "#/definitions/Coordinate"
        }
      }
    },
    "Coordinate": {
      "type": "object",
      "properties": {
        "latitude": {
          "type": "number",
          "format": "double"
        },
        "longitude": {
          "type": "number",
          "format": "double"
        }
      }
    },
    "CostDetails": {
      "type": "object",
      "properties": {
        "driverCost": {
          "type": "string",
          "description": "computed from request's driver_cost value and the travel time (with or without ferry time)"
        },
        "energyCost": {
          "type": "string",
          "description": "computed based on request's consumptiondetails"
        },
        "optionalValue": {
          "type": "string",
          "description": "value earned by picking + dropping optional waypoints"
        },
        "tollCost": {
          "type": "string",
          "description": "total toll fee"
        },
        "totalCost": {
          "type": "number",
          "format": "double"
        },
        "vehicleCost": {
          "type": "string",
          "description": "computed from request's vehicle_cost value and the travel distance (with or without ferry travel)"
        }
      }
    },
    "Costs": {
      "type": "object",
      "properties": {
        "currency": {
          "type": "string",
          "description": "currency unit of the costs"
        },
        "details": {
          "$ref": "#/definitions/CostDetails"
        },
        "totalCost": {
          "type": "string",
          "description": "sum of all cost elements"
        }
      }
    },
    "CurrencyAmount": {
      "type": "object",
      "properties": {
        "adminId": {
          "type": "string",
          "description": "country's admin place id"
        },
        "amountInTargetCurrency": {
          "type": "number",
          "format": "double"
        },
        "country": {
          "type": "string"
        },
        "languageCode": {
          "type": "string",
          "description": "Language code of toll system name"
        },
        "name": {
          "type": "string",
          "description": "Toll system name"
        },
        "tollSystemId": {
          "type": "string"
        }
      }
    },
    "DeleteLayersResponse": {
      "type": "object",
      "properties": {
        "deletedLayers": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "Geometry": {
      "type": "object",
      "properties": {
        "attributes": {
          "type": "object",
          "description": "Attribute/value map",
          "additionalProperties": {
            "type": "string"
          }
        },
        "geometry": {
          "type": "string",
          "description": "WKT string"
        }
      }
    },
    "GeometrySearchResponse": {
      "type": "object",
      "properties": {
        "geometries": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Geometry"
          }
        },
        "meta": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/SearchMetaResponse"
          }
        }
      }
    },
    "IndexDocBean": {
      "type": "object",
      "properties": {
        "exampleNames": {
          "type": "string"
        },
        "exampleUrlParams": {
          "type": "string"
        },
        "indexedColumnNames": {
          "type": "string"
        },
        "indexedLayerName": {
          "type": "string"
        }
      }
    },
    "IndexResponse": {
      "type": "object",
      "properties": {
        "Layers": {
          "type": "array",
          "description": "List of layers containing this attribute value. Usually 1 layer, but can be multiple when request a ..._FCN layer.",
          "items": {
            "$ref": "#/definitions/IndexResponseLayer"
          }
        }
      }
    },
    "IndexResponseLayer": {
      "type": "object",
      "properties": {
        "layer": {
          "type": "string"
        },
        "level": {
          "type": "integer",
          "format": "int32",
          "description": "Tiling level of the layer."
        },
        "tileXYs": {
          "type": "array",
          "description": "tileX and tileY components of the tile ID.",
          "items": {
            "$ref": "#/definitions/IndexTileCoords"
          }
        }
      }
    },
    "IndexTileCoords": {
      "type": "object",
      "properties": {
        "x": {
          "type": "integer",
          "format": "int32"
        },
        "y": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "KeyValue": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string"
        },
        "value": {
          "type": "object"
        }
      }
    },
    "LayerDetailDocBean": {
      "type": "object",
      "properties": {
        "attributes": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "description": {
          "type": "string"
        },
        "isStaticContent": {
          "type": "boolean"
        },
        "referencedStaticContents": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "tileRequestsLevel": {
          "type": "integer",
          "format": "int32"
        },
        "tileX": {
          "type": "integer",
          "format": "int32"
        },
        "tileY": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "LayerDocBean": {
      "type": "object",
      "properties": {
        "attributes": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "featureMapping": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "tileLevel": {
          "type": "integer",
          "format": "int32"
        },
        "type": {
          "type": "string"
        }
      }
    },
    "LayerModifyResponse": {
      "type": "object",
      "properties": {
        "action": {
          "type": "string"
        }
      }
    },
    "LayerPermissionResponse": {
      "type": "object"
    },
    "LayerUploadResponse": {
      "type": "object",
      "properties": {
        "storedTilesCount": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "Leg": {
      "type": "object",
      "properties": {
        "arrivalBatteryCharge": {
          "type": "number",
          "format": "double",
          "description": "Indicates battery energy when reaching the recharge waypoint. Only available if the maneuver has a chargingStopOver."
        },
        "baseTime": {
          "type": "integer",
          "format": "int32"
        },
        "boundingBox": {
          "$ref": "#/definitions/BoundingBox"
        },
        "firstPoint": {
          "type": "integer",
          "format": "int32"
        },
        "lastPoint": {
          "type": "integer",
          "format": "int32"
        },
        "length": {
          "type": "integer",
          "format": "int32"
        },
        "link": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Link"
          }
        },
        "maneuver": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Maneuver"
          }
        },
        "shape": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "double"
          }
        },
        "stayingTime": {
          "type": "integer",
          "format": "int32",
          "description": "Indicates time spent on recharging(in seconds). Only available if the maneuver has a chargingStopOver."
        },
        "targetBatteryCharge": {
          "type": "number",
          "format": "double",
          "description": "Indicates battery energy after charging when leaving the recharge waypoint. Only available if the maneuver has a chargingStopOver."
        },
        "trafficTime": {
          "type": "integer",
          "format": "int32"
        },
        "travelTime": {
          "type": "integer",
          "format": "int32"
        },
        "turnByTurnManeuver": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TurnByTurnManeuver"
          }
        }
      }
    },
    "Link": {
      "type": "object",
      "properties": {
        "attributes": {
          "type": "object",
          "description": "requested PDE layer attributes for the link",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/KeyValue"
              }
            }
          }
        },
        "confidence": {
          "type": "number",
          "format": "double",
          "description": "0...1 link match confidence (only for route match mode)"
        },
        "consumption": {
          "type": "number",
          "format": "double",
          "description": "energy consumption to traverse the link, in target currency"
        },
        "cost": {
          "description": "cost to traverse the link",
          "$ref": "#/definitions/CostDetails"
        },
        "functionalClass": {
          "type": "integer",
          "format": "int32"
        },
        "length": {
          "type": "number",
          "format": "double",
          "description": "meter"
        },
        "linkId": {
          "type": "string",
          "description": "Permanent version id (HERE core map)"
        },
        "remainDistance": {
          "type": "integer",
          "format": "int64",
          "description": "meters, for the entire route (not just in between legs)"
        },
        "remainTime": {
          "type": "integer",
          "format": "int64",
          "description": "seconds, for the entire route (not just in between legs)"
        },
        "shape": {
          "type": "array",
          "description": "List of WGS84 degree latitude/longitude coordinates in driving direction sequence order",
          "items": {
            "type": "number",
            "format": "double"
          }
        },
        "timezone": {
          "type": "integer",
          "format": "int32",
          "description": "Timezone offset to UTC in minutes when the time zone of the link changes compared to previous link"
        },
        "warning": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ResponseIssue"
          }
        }
      }
    },
    "ListLayersResponse": {
      "type": "object",
      "properties": {
        "layers": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "Maneuver": {
      "type": "object",
      "properties": {
        "action": {
          "type": "string"
        },
        "direction": {
          "type": "string"
        },
        "firstPoint": {
          "type": "integer",
          "format": "int32"
        },
        "id": {
          "type": "string"
        },
        "instruction": {
          "type": "string",
          "description": "tagged driver instruction text in the requested language"
        },
        "lanes": {
          "type": "string"
        },
        "lastPoint": {
          "type": "integer",
          "format": "int32"
        },
        "length": {
          "type": "integer",
          "format": "int32",
          "description": "Distance [meter] to drive until to this maneuver point"
        },
        "position": {
          "$ref": "#/definitions/ManeuverPosition"
        },
        "travelTime": {
          "type": "integer",
          "format": "int32",
          "description": "Time [sec] to drive until to this maneuver point"
        }
      }
    },
    "ManeuverPosition": {
      "type": "object",
      "properties": {
        "latitude": {
          "type": "number",
          "format": "double"
        },
        "longitude": {
          "type": "number",
          "format": "double"
        }
      }
    },
    "MapDocBean": {
      "type": "object",
      "properties": {
        "coverage": {
          "type": "string"
        },
        "isLatest": {
          "type": "boolean"
        },
        "name": {
          "type": "string"
        },
        "releaseYearAndQuarter": {
          "type": "string"
        },
        "size": {
          "type": "integer",
          "format": "int64"
        },
        "version": {
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "MapDocResponse": {
      "type": "object",
      "properties": {
        "maps": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MapDocBean"
          }
        }
      }
    },
    "MatchedVehicleType": {
      "type": "object",
      "properties": {
        "confidence": {
          "type": "number",
          "format": "double",
          "description": "confidence value of the match 0 ... 1"
        },
        "subType": {
          "type": "string",
          "description": "light, medium or heavy, applicable only for truck"
        },
        "type": {
          "type": "string",
          "description": "car, truck or pedestrian"
        }
      }
    },
    "OverlaySubmitResponse": {
      "type": "object",
      "properties": {
        "layers": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "meta": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/SearchMetaResponse"
          }
        },
        "warnings": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "Pass": {
      "type": "object",
      "properties": {
        "annual": {
          "type": "boolean"
        },
        "extendedAnnual": {
          "type": "boolean"
        },
        "id": {
          "type": "integer",
          "format": "int32"
        },
        "nrOfDays": {
          "type": "integer",
          "format": "int32"
        },
        "nrOfMonths": {
          "type": "integer",
          "format": "int32"
        },
        "seniorPass": {
          "type": "boolean"
        }
      }
    },
    "Response": {
      "type": "object",
      "properties": {
        "language": {
          "type": "string",
          "description": "Language used in maneuver instructions. 2 letter language code + 2 letter ISO country code."
        },
        "route": {
          "type": "array",
          "description": "Route alternatives. The first route alternative has the minimum cost.",
          "items": {
            "$ref": "#/definitions/Route"
          }
        },
        "warnings": {
          "type": "array",
          "description": "Warnings that are either globally for the request or apply to the first route alternative.",
          "items": {
            "$ref": "#/definitions/ResponseIssue"
          }
        }
      },
      "description": "Calculate route response"
    },
    "ResponseIssue": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "duration": {
          "type": "integer",
          "format": "int64"
        },
        "isoCountryCode": {
          "type": "string"
        },
        "message": {
          "type": "string"
        },
        "operation": {
          "type": "string"
        },
        "plannedWayPointSeqNum": {
          "type": "integer",
          "format": "int32"
        },
        "routeLinkSeqNum": {
          "type": "integer",
          "format": "int32"
        },
        "toTracePointSeqNum": {
          "type": "integer",
          "format": "int32"
        },
        "tracePointSeqNum": {
          "type": "integer",
          "format": "int32"
        },
        "truckRestrictionCategoryCode": {
          "type": "integer",
          "format": "int32"
        },
        "wayPointSeqNum": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "RoadName": {
      "type": "object",
      "properties": {
        "language": {
          "type": "string"
        },
        "text": {
          "type": "string"
        }
      }
    },
    "Route": {
      "type": "object",
      "properties": {
        "boatFerry": {
          "type": "boolean",
          "example": false,
          "description": "set if the route uses a boat ferry"
        },
        "boundingBox": {
          "$ref": "#/definitions/BoundingBox"
        },
        "cost": {
          "$ref": "#/definitions/Costs"
        },
        "leg": {
          "type": "array",
          "description": "one leg traverses between two mandatory stopover waypoints",
          "items": {
            "$ref": "#/definitions/Leg"
          }
        },
        "matchedVehicleType": {
          "type": "array",
          "description": "most probable vehicle type(s), only for route match mode",
          "items": {
            "$ref": "#/definitions/MatchedVehicleType"
          }
        },
        "mode": {
          "description": "from the request",
          "$ref": "#/definitions/RouteMode"
        },
        "railFerry": {
          "type": "boolean",
          "example": false,
          "description": "set if the route uses a rail ferry"
        },
        "shape": {
          "type": "array",
          "items": {
            "type": "number",
            "format": "double"
          }
        },
        "summary": {
          "$ref": "#/definitions/Summary"
        },
        "summaryByCountry": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/RouteSummaryByCountry"
          }
        },
        "tollCost": {
          "description": "the requested toll cost rollups",
          "$ref": "#/definitions/TCResponse"
        },
        "waypoint": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/WayPoint"
          }
        }
      }
    },
    "RouteMode": {
      "type": "object",
      "properties": {
        "trafficMode": {
          "type": "string",
          "description": "from request: disabled or enabled"
        },
        "transportModes": {
          "type": "array",
          "description": "request's vehicle type",
          "items": {
            "type": "string"
          }
        },
        "type": {
          "type": "string",
          "description": "from request: shortest, fastest or matched (route match mode)"
        }
      }
    },
    "RouteSummaryByCountry": {
      "type": "object",
      "properties": {
        "baseTime": {
          "type": "integer",
          "format": "int64",
          "description": "travel time [sec] without considering traffic impact (use only if mode=traffic:disabled)"
        },
        "country": {
          "type": "string",
          "description": "ISO country code"
        },
        "distance": {
          "type": "integer",
          "format": "int64",
          "description": "travel distance [meter]"
        },
        "tollRoadDistance": {
          "type": "integer",
          "format": "int64",
          "description": "toll road distance [meter]"
        },
        "trafficTime": {
          "type": "integer",
          "format": "int64",
          "description": "travel time [sec] considering traffic impact (use only if mode=traffic:enabled)"
        },
        "travelTime": {
          "type": "integer",
          "format": "int64",
          "description": "travel time [sec] without considering traffic impact (use only if mode=traffic:disabled)"
        }
      }
    },
    "RouteTollItem": {
      "type": "object",
      "properties": {
        "adminId": {
          "type": "integer",
          "format": "int32",
          "description": "Admin place id of the country"
        },
        "conditionId": {
          "type": "integer",
          "format": "int32",
          "description": "Core map condition id, either type Toll Both or Usage Fee Required"
        },
        "country": {
          "type": "string",
          "description": "3 letter ISO country code"
        },
        "linkIds": {
          "type": "array",
          "description": "Sequence of link ids covered by this toll fee",
          "items": {
            "type": "integer",
            "format": "int64"
          }
        },
        "tollCostAlternatives": {
          "type": "array",
          "description": "toll fee alternatives, depending on vehicle type, time of day, day of week, month, payment method, pass, transponder...",
          "items": {
            "$ref": "#/definitions/TollCost"
          }
        },
        "tollStructures": {
          "type": "array",
          "description": "Toll booth(s)/bridge(s) at start and/or end of this toll section",
          "items": {
            "$ref": "#/definitions/TollStructure"
          }
        },
        "tollSystem": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TSystem"
          }
        },
        "tollType": {
          "type": "string"
        },
        "usageFeeRequiredTime": {
          "type": "string",
          "description": "Date/time definition when this toll fee applies, in the same format as in all map layers' DATE_TIMES fields"
        }
      }
    },
    "SearchMetaResponse": {
      "type": "object",
      "properties": {
        "lastUpdateTimeStamp": {
          "type": "integer",
          "format": "int64",
          "description": "last modification milli second timestamp"
        },
        "layerId": {
          "type": "string",
          "description": "the layername the geometry belongs to"
        },
        "search": {
          "type": "string"
        }
      }
    },
    "ServiceConfigurationContent": {
      "type": "object",
      "properties": {
        "maxGetLinkInfoLinkIdsPerRequest": {
          "type": "string"
        },
        "maxIndexValuesPerRequest": {
          "type": "string"
        },
        "maxProximityLayers": {
          "type": "string"
        },
        "maxSearchResults": {
          "type": "string"
        },
        "maxTilesPerRequest": {
          "type": "string"
        }
      }
    },
    "ServiceConfigurationResponse": {
      "type": "object",
      "properties": {
        "Configuration": {
          "$ref": "#/definitions/ServiceConfigurationContent"
        }
      }
    },
    "StaticContentDetailDocBean": {
      "type": "object",
      "properties": {
        "attributes": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "description": {
          "type": "string"
        },
        "referencingLayers": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "StaticContentDocBean": {
      "type": "object",
      "properties": {
        "attributes": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "name": {
          "type": "string"
        },
        "referencingLayers": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "Summary": {
      "type": "object",
      "properties": {
        "arrival": {
          "type": "string",
          "description": "same or earlier than request's arrival time"
        },
        "baseTime": {
          "type": "integer",
          "format": "int64",
          "description": "travel time [sec] without considering traffic impact (use only if mode=traffic:disabled)"
        },
        "departure": {
          "type": "string",
          "description": "same or later than request's departure time"
        },
        "distance": {
          "type": "integer",
          "format": "int64",
          "description": "travel distance [meter]"
        },
        "flags": {
          "type": "array",
          "description": "currently unused",
          "items": {
            "type": "string"
          }
        },
        "trafficTime": {
          "type": "integer",
          "format": "int64",
          "description": "travel time [sec] considering traffic impact (use only if mode=traffic:enabled)"
        },
        "travelTime": {
          "type": "integer",
          "format": "int64",
          "description": "travel time [sec]"
        }
      }
    },
    "TCResponse": {
      "type": "object",
      "properties": {
        "costsByCountry": {
          "type": "array",
          "description": "total toll cost per country",
          "items": {
            "$ref": "#/definitions/CurrencyAmount"
          }
        },
        "costsByCountryAndTollSystem": {
          "type": "array",
          "description": "total toll cost per country and toll system",
          "items": {
            "$ref": "#/definitions/CurrencyAmount"
          }
        },
        "costsByTollSystem": {
          "type": "array",
          "description": "total toll cost per toll system",
          "items": {
            "$ref": "#/definitions/CurrencyAmount"
          }
        },
        "routeTollItems": {
          "type": "array",
          "description": "list of all toll cost items (for rollups=none)",
          "items": {
            "$ref": "#/definitions/RouteTollItem"
          }
        },
        "totalCost": {
          "$ref": "#/definitions/CurrencyAmount"
        }
      }
    },
    "TSystem": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int32"
        },
        "languageCode": {
          "type": "string"
        },
        "name": {
          "type": "string"
        }
      }
    },
    "TileResponse": {
      "type": "object",
      "properties": {
        "columnNames": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "rows": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TileRow"
          }
        }
      }
    },
    "TileRow": {
      "type": "object",
      "properties": {
        "columns": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "TollCost": {
      "type": "object",
      "properties": {
        "amount": {
          "type": "number",
          "format": "double",
          "description": "fee in native currency unit"
        },
        "amountInTargetCurrency": {
          "type": "number",
          "format": "double"
        },
        "currency": {
          "type": "string",
          "description": "the native currency unit"
        },
        "daylightHours": {
          "type": "integer",
          "format": "int32"
        },
        "discountAvailable": {
          "type": "integer",
          "format": "int32"
        },
        "ferryType": {
          "type": "string"
        },
        "levelOfAccuracy": {
          "type": "string"
        },
        "methodOfPayment": {
          "type": "integer",
          "format": "int32"
        },
        "pass": {
          "$ref": "#/definitions/Pass"
        },
        "time": {
          "type": "string"
        },
        "vehicleSpecification": {
          "$ref": "#/definitions/VehicleSpecification"
        }
      }
    },
    "TollStructure": {
      "type": "object",
      "properties": {
        "conditionId": {
          "type": "integer",
          "format": "int32"
        },
        "languageCode": {
          "type": "string"
        },
        "latitude": {
          "type": "number",
          "format": "double"
        },
        "linkIds": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int64"
          }
        },
        "longitude": {
          "type": "number",
          "format": "double"
        },
        "name": {
          "type": "string"
        }
      }
    },
    "TurnByTurnManeuver": {
      "type": "object",
      "properties": {
        "action": {
          "type": "string"
        },
        "direction": {
          "type": "string"
        },
        "distanceToNextManeuver": {
          "type": "integer",
          "format": "int32"
        },
        "firstPoint": {
          "type": "integer",
          "format": "int32"
        },
        "id": {
          "type": "string"
        },
        "instruction": {
          "type": "string",
          "description": "tagged driver instruction text in the requested language"
        },
        "lanes": {
          "type": "string"
        },
        "lastPoint": {
          "type": "integer",
          "format": "int32"
        },
        "length": {
          "type": "integer",
          "format": "int32",
          "description": "Distance [meter] to drive until to this maneuver point"
        },
        "nextRoadName": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/RoadName"
          }
        },
        "orientation": {
          "type": "string"
        },
        "position": {
          "$ref": "#/definitions/ManeuverPosition"
        },
        "roadName": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/RoadName"
          }
        },
        "routeLinkIndex": {
          "type": "integer",
          "format": "int32"
        },
        "travelTime": {
          "type": "integer",
          "format": "int32",
          "description": "Time [sec] to drive until to this maneuver point"
        },
        "turn": {
          "type": "string"
        }
      }
    },
    "VehicleSpecification": {
      "type": "object",
      "properties": {
        "commercial": {
          "type": "boolean"
        },
        "disabledEquipped": {
          "type": "boolean"
        },
        "emissionType": {
          "type": "string"
        },
        "fuelType": {
          "type": "string"
        },
        "heightAbove1stAxleMax": {
          "type": "integer",
          "format": "int32"
        },
        "heightAbove1stAxleMin": {
          "type": "integer",
          "format": "int32"
        },
        "heightMax": {
          "type": "integer",
          "format": "int32"
        },
        "heightMin": {
          "type": "integer",
          "format": "int32"
        },
        "hov": {
          "type": "boolean"
        },
        "hybrid": {
          "type": "boolean"
        },
        "lengthMax": {
          "type": "integer",
          "format": "int32"
        },
        "lengthMin": {
          "type": "integer",
          "format": "int32"
        },
        "limitedWeightMax": {
          "type": "integer",
          "format": "int32"
        },
        "limitedWeightMin": {
          "type": "integer",
          "format": "int32"
        },
        "minimalPollution": {
          "type": "boolean"
        },
        "passengersCountMax": {
          "type": "integer",
          "format": "int32"
        },
        "passengersCountMin": {
          "type": "integer",
          "format": "int32"
        },
        "personFee": {
          "type": "boolean"
        },
        "shippedHazardousGoods": {
          "type": "string"
        },
        "tiresCountMax": {
          "type": "integer",
          "format": "int32"
        },
        "tiresCountMin": {
          "type": "integer",
          "format": "int32"
        },
        "tollVehicleType": {
          "type": "string"
        },
        "trailerHeightMax": {
          "type": "integer",
          "format": "int32"
        },
        "trailerHeightMin": {
          "type": "integer",
          "format": "int32"
        },
        "trailerNumberAxlesMax": {
          "type": "integer",
          "format": "int32"
        },
        "trailerNumberAxlesMin": {
          "type": "integer",
          "format": "int32"
        },
        "trailerType": {
          "type": "string"
        },
        "trailersCount": {
          "type": "integer",
          "format": "int32"
        },
        "vehicleNumberAxlesMax": {
          "type": "integer",
          "format": "int32"
        },
        "vehicleNumberAxlesMin": {
          "type": "integer",
          "format": "int32"
        },
        "vehicleWeightMax": {
          "type": "integer",
          "format": "int32"
        },
        "vehicleWeightMin": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "WayPoint": {
      "type": "object",
      "properties": {
        "mappedPosition": {
          "description": "map matched coordinate",
          "$ref": "#/definitions/Coordinate"
        },
        "mappedRoadName": {
          "type": "string",
          "description": "Base name of the road. Empty means unknown or valid unnamed."
        },
        "originalPosition": {
          "description": "from request",
          "$ref": "#/definitions/Coordinate"
        },
        "seqNrOnRoute": {
          "type": "integer",
          "format": "int32",
          "description": "index of the link in the route (duplicate link entries at start/end of a leg are counted only once)"
        },
        "shapeIndex": {
          "type": "integer",
          "format": "int32",
          "description": "index of the first shape coordinate in the shape array"
        },
        "sideOfStreet": {
          "type": "string",
          "description": "indicates whether the waypoint is on the left or right side of the link in the direction of driving. Possible values are left|right|neither. The value 'neither' means that the waypoint is within 3 meters range away from the link"
        },
        "spot": {
          "type": "number",
          "format": "double",
          "description": "0...1 relative matched offset on link from reference node"
        },
        "type": {
          "type": "string",
          "description": "indicate whether waypoint is passThrough or stopOver"
        },
        "waypointType": {
          "type": "string",
          "description": "indicate whether waypoint is planned waypoint, learned stop or last tracepoint from RME"
        }
      }
    }
  }
}